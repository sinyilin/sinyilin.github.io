<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用 Github Actions 自動化部署 Hexo 到 Github Pages 個人部落格</title>
    <url>/Git/20240908/3475006884/</url>
    <content><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>每次更新 Blog 文章，皆需手動執行指令部屬有點小麻煩 (指令可以參考 <a href="https://sinyilin.github.io/hexo/20190924/3166793059/">使用GitHub + Hexo 建立個人blogger 中第9點 發表文章</a>)。<br>原本從 Local 端執行部屬指令時，上傳到 Github Pages 的檔案只有編譯過後的靜態網頁檔案，之前有提過如果Blog 原始草稿檔不見的話會很難復原，所以趁著這個機會將 Blog 原始草稿檔案交由 GitHub 管理，也透過 Github Actions 功能自動化部署簡化更新 Blog 文章的流程。</p><a id="more"></a>
<h2 id="作法"><a href="#作法" class="headerlink" title="作法"></a>作法</h2><h3 id="Step1-在-GitHub-上，新增一個-private-的-repository-存放-Blog-原始草稿"><a href="#Step1-在-GitHub-上，新增一個-private-的-repository-存放-Blog-原始草稿" class="headerlink" title="Step1. 在 GitHub 上，新增一個 private 的 repository 存放 Blog 原始草稿"></a>Step1. 在 GitHub 上，新增一個 private 的 repository 存放 Blog 原始草稿</h3><h3 id="Step2-產出-SSH-部署私鑰"><a href="#Step2-產出-SSH-部署私鑰" class="headerlink" title="Step2. 產出 SSH 部署私鑰"></a>Step2. 產出 SSH 部署私鑰</h3><p>若先前有設定過 GitHub 配置的 Global SSH key 可以跳過這個步驟。<br>沒有設定過的話，可以參考我之前寫的這篇文章產出公私鑰與設定 Global SSH key <a href="https://sinyilin.github.io/git/20211001/714155446/">解決Github push 身份驗證失敗</a>。</p>
<h3 id="Step3-調整-Step1-Blog-原始草稿-repository-部署私鑰"><a href="#Step3-調整-Step1-Blog-原始草稿-repository-部署私鑰" class="headerlink" title="Step3. 調整 Step1.Blog 原始草稿 repository 部署私鑰"></a>Step3. 調整 Step1.Blog 原始草稿 repository 部署私鑰</h3><p>路徑:Settings &gt; Secrets and variables &gt; Actions &gt; New repository secret</p>
<p><img src="/images/use-github-actions-deploy-hexo/1.png" alt></p>
<p>Name : 輸入 HEXO_SSH_PRIVATE_KEY<br>Value : 輸入SSH 部署私鑰產出的內容</p>
<p>請注意 HEXO_SSH_PRIVATE_KEY 這個名稱後續會在yml配置中用到，兩邊必須一致，否則執行部屬時，會讀取不到鑰匙。</p>
<h3 id="Step4-在原始草稿-repository，新增-GitHub-Action-設定與寫-workflow-腳本"><a href="#Step4-在原始草稿-repository，新增-GitHub-Action-設定與寫-workflow-腳本" class="headerlink" title="Step4. 在原始草稿 repository，新增 GitHub Action 設定與寫 workflow 腳本"></a>Step4. 在原始草稿 repository，新增 GitHub Action 設定與寫 workflow 腳本</h3><p>路徑: Actions &gt; New workflow &gt; set up a workflow yourself.<br><img src="/images/use-github-actions-deploy-hexo/2.png" alt></p>
<p>基本上 github 會另外開個虛擬機作為workflow 的執行環境，會依照<code>yml</code>中的指令執行。</p>
<p>以下是我的<code>yml</code>設定：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置檔名稱</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">Deploy</span></span><br><span class="line"><span class="comment"># 進行什麼行為時觸發，也可多行為觸發，例如[push, fork] ，多個觸發行為可以用 [push]表示，這邊指定只有 master branch 被異動時才會觸發部署</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line"><span class="attr">  push:</span></span><br><span class="line"><span class="attr">    branches:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="attr">  pages:</span></span><br><span class="line">    <span class="comment"># 環境提供作業系統，目前提供Windows, macOS, Ubuntu，詳細查閱（https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#choosing-github-hosted-runners）</span></span><br><span class="line"><span class="attr">    runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"><span class="attr">    steps:</span></span><br><span class="line">      <span class="comment"># 拉取當前Repository的分支main的Code到他們的容器（如配置檔中使用的Runs-on的Ubuntu）上</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">Checkout</span></span><br><span class="line"><span class="attr">        uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"><span class="attr">        with:</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 安裝Nodejs環境</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">12</span></span><br><span class="line"><span class="attr">        uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line"><span class="attr">        with:</span></span><br><span class="line"><span class="attr">          node-version:</span> <span class="string">'12'</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 緩存</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">Cache</span> <span class="string">NPM</span> <span class="string">Dependencies</span></span><br><span class="line"><span class="attr">        uses:</span> <span class="string">actions/cache@v2</span></span><br><span class="line"><span class="attr">        with:</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">node_modules</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.OS</span> <span class="string">&#125;&#125;-npm-cache</span></span><br><span class="line"><span class="attr">          restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            $<span class="template-variable">&#123;&#123; runner.OS &#125;&#125;</span>-npm-cache</span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">      # 增加SSH KEY的配置</span></span><br><span class="line"><span class="string"></span><span class="attr">      - name:</span> <span class="string">Add</span> <span class="string">SSH</span> <span class="string">Private</span> <span class="string">Key</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">          SSH_PRIVATE:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HEXO_SSH_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">        run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">          echo "$SSH_PRIVATE" &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string">          chmod 700 -R ~/.ssh        </span></span><br><span class="line"><span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">          git config --global user.email "xxxxx@gmail.com"</span></span><br><span class="line"><span class="string">          git config --global user.name "xxxxx"</span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string">      # 安裝Hexo需要的環境（針對Hexo根目錄的package.json）</span></span><br><span class="line"><span class="string"></span><span class="attr">      - name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line"><span class="attr">        run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm install hexo-cli -g</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string">          npm install hexo-generator-sitemap --save</span></span><br><span class="line"><span class="string">      # 一鍵化部署</span></span><br><span class="line"><span class="string"></span><span class="attr">      - name:</span> <span class="string">Hexo</span> <span class="string">Deploy</span></span><br><span class="line"><span class="attr">        run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          hexo clean</span></span><br><span class="line"><span class="string">          hexo d -g</span></span><br></pre></td></tr></table></figure>

<h3 id="Step5-發表文章"><a href="#Step5-發表文章" class="headerlink" title="Step5. 發表文章"></a>Step5. 發表文章</h3><p>依照上方<code>yml</code>檔案設定只要將草稿 commit 到指定的branch (master)，就可以輕輕鬆鬆的發佈新文章了！<br>每 commit 一次就會有對應的部屬紀錄<br><img src="/images/use-github-actions-deploy-hexo/4.png" alt></p>
<h3 id="Step6-Deploy-失敗除錯方法"><a href="#Step6-Deploy-失敗除錯方法" class="headerlink" title="Step6. Deploy 失敗除錯方法"></a>Step6. Deploy 失敗除錯方法</h3><p>當你發表文章後，遲遲沒有看到網頁的更新，<br>可以查看每次的部屬紀錄，如果有報錯，這邊會展示錯誤訊息。<br><img src="/images/use-github-actions-deploy-hexo/5.png" alt></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Git</tag>
        <tag>Hexo</tag>
        <tag>CD</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring boot 開發 - 使用 Jasypt 進行加密</title>
    <url>/spring-boot/20240823/2374258038/</url>
    <content><![CDATA[<h2 id="Jasypt-介紹"><a href="#Jasypt-介紹" class="headerlink" title="Jasypt 介紹"></a>Jasypt 介紹</h2><p>系統中有一些重要的資訊是不能明碼的展示在程式碼中，比如密碼、API 密鑰等，以免被有心人士拿去利用，此時就會需要一個加密的工具。<br>Jasypt 是一個 Java 的加密Library，它提供簡單易用的API與配置，讓開發者可以在不需要深入了解加密演算法的情況下，也能輕鬆的在程式中實作加密與解密功能。</p><a id="more"></a>
<h2 id="如何使用-jasypt-加密"><a href="#如何使用-jasypt-加密" class="headerlink" title="如何使用 jasypt 加密"></a>如何使用 jasypt 加密</h2><p>在使用 Jasypt 進行加密時，大致流程如下：</p>
<ul>
<li>加密密碼：首先，通過 Jasypt 提供的工具或命令行界面，將需要加密的密碼轉換為加密字串。這個加密字串可以安全地存儲在配置文件中，而不會洩露敏感信息。</li>
<li>引入依賴：在 應用程式中，引入 Jasypt 的 dependency，確保應用能夠使用 Jasypt 的加密和解密功能。</li>
<li>配置加密字串：將生成的加密字串放入應用的配置文件中，例如 application.properties 或 application.yml。應用在運行時，會自動使用 Jasypt 進行解密，並將解密後的值提供給程式使用。</li>
</ul>
<h3 id="Step1-透過-jasypt-加密，取得加密後字串"><a href="#Step1-透過-jasypt-加密，取得加密後字串" class="headerlink" title="Step1. 透過 jasypt 加密，取得加密後字串"></a>Step1. 透過 jasypt 加密，取得加密後字串</h3><p>取得 jasypt 加密後的字串有很多種方式，以下說明三種方式</p>
<h3 id="寫個小程式加密"><a href="#寫個小程式加密" class="headerlink" title="寫個小程式加密"></a>寫個小程式加密</h3><p>以下範例是寫在Junit中執行，也可參考部分的sample coder寫在主程式中，執行後會產生出一組加密後字串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.testJasypt.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.testJasypt.web.service.BaseService;</span><br><span class="line"><span class="keyword">import</span> org.jasypt.encryption.pbe.StandardPBEStringEncryptor;</span><br><span class="line"><span class="keyword">import</span> org.jasypt.encryption.pbe.config.EnvironmentPBEConfig;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ActiveProfiles;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@ActiveProfiles</span>(profiles = <span class="string">"dev"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebApplicationTests</span> <span class="keyword">extends</span> <span class="title">BaseService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ALGORITHM = <span class="string">"PBEWithMD5AndDES"</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ENCRYPT_KEY = <span class="string">"EbfYkitulv73I2p0mXI50JMXoaxZTKJ7"</span>;</span><br><span class="line">    	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String text = <span class="string">"123456"</span>;</span><br><span class="line">		EncryptAndDecrypt(text);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EncryptAndDecrypt</span><span class="params">(String plainText)</span> </span>&#123;</span><br><span class="line">          StandardPBEStringEncryptor standardPBEStringEncryptor = <span class="keyword">new</span> StandardPBEStringEncryptor();</span><br><span class="line">          EnvironmentPBEConfig config = <span class="keyword">new</span> EnvironmentPBEConfig();</span><br><span class="line">       </span><br><span class="line">          config.setAlgorithm(ALGORITHM);          <span class="comment">// 加密的算法，這個是default的演算法，可以指定別種加密演算法</span></span><br><span class="line">          config.setPassword(ENCRYPT_KEY);         <span class="comment">// 加密的密鑰</span></span><br><span class="line">          standardPBEStringEncryptor.setConfig(config);</span><br><span class="line">        </span><br><span class="line">          System.out.println(<span class="string">"0. 加密前的字串  -------------------------"</span>);</span><br><span class="line">          System.out.println(plainText);</span><br><span class="line">        </span><br><span class="line">          System.out.println(<span class="string">"1. 加密後的字串  Encryptc-------------------------"</span>);</span><br><span class="line">          String encryptedText = standardPBEStringEncryptor.encrypt(plainText);</span><br><span class="line">          System.out.println(encryptedText);</span><br><span class="line">        </span><br><span class="line">      	  System.out.println(<span class="string">"2.  解密後的字串 Decrypt-------------------------"</span>);</span><br><span class="line">          String afterDecrypt = standardPBEStringEncryptor.decrypt(encryptedText);</span><br><span class="line">          System.out.println(afterDecrypt);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="透過-Command-Line-執行-jar-加密"><a href="#透過-Command-Line-執行-jar-加密" class="headerlink" title="透過 Command Line 執行 jar 加密"></a>透過 Command Line 執行 jar 加密</h3><ul>
<li><p>到 <code>.m2</code> 資料夾下找到jasypt library，執行以下指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#  java -cp jasypt-1.9.3.jar org.jasypt.intf.cli.JasyptPBEStringEncryptionCLI input=&quot;&#123;原始密碼&#125;&quot; password=&#123;加密的密鑰&#125; algorithm=&#123;加密的演算法&#125;</span><br><span class="line"></span><br><span class="line">java -cp jasypt-1.9.3.jar org.jasypt.intf.cli.JasyptPBEStringEncryptionCLI input=&quot;root&quot; password=spring algorithm=PBEWithMD5AndDES</span><br></pre></td></tr></table></figure>
</li>
<li><p>執行結果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----ENVIRONMENT-----------------</span><br><span class="line"></span><br><span class="line">Runtime: Oracle Corporation OpenJDK 64-Bit Server VM 15.0.1+9-18</span><br><span class="line"></span><br><span class="line">----ARGUMENTS-------------------</span><br><span class="line"></span><br><span class="line">input: 123456</span><br><span class="line">password: EbfYkitulv73I2p0mXI50JMXoaxZTKJ7</span><br><span class="line">algorithm: PBEWithMD5AndDES</span><br><span class="line"></span><br><span class="line">----OUTPUT----------------------</span><br><span class="line"></span><br><span class="line">YidAq+TOHJ3lCI+SqFhOJA==</span><br></pre></td></tr></table></figure>
</li>
<li><p>執行結果截圖<br><img src="/images/spring-boot-jasypt/1.png" alt></p>
</li>
</ul>
<h3 id="使用線上小工具加密"><a href="#使用線上小工具加密" class="headerlink" title="使用線上小工具加密"></a>使用線上小工具加密</h3><p>沒有執行環境，可以直接使用線上網站來加密，也可以達到一樣的效果，不過這個網站目前只能使用default的 <code>PBEWithMD5AndDES</code> 演算法 。<br><a href="https://www.devglan.com/online-tools/jasypt-online-encryption-decryption" target="_blank" rel="noopener">https://www.devglan.com/online-tools/jasypt-online-encryption-decryption</a></p>
<h2 id="Step2-引入依賴與配置加密字串，將加密字串後應用在-Spring-Boot"><a href="#Step2-引入依賴與配置加密字串，將加密字串後應用在-Spring-Boot" class="headerlink" title="Step2. 引入依賴與配置加密字串，將加密字串後應用在 Spring Boot"></a>Step2. 引入依賴與配置加密字串，將加密字串後應用在 Spring Boot</h2><p>如果要應用在資料庫密碼加密上的話，在取得加密字串後，需要做以下動作：</p>
<h3 id="引入Maven-dependency，在-POM-xml-中新增-dependency"><a href="#引入Maven-dependency，在-POM-xml-中新增-dependency" class="headerlink" title="引入Maven dependency，在 POM.xml 中新增 dependency"></a>引入Maven dependency，在 <code>POM.xml</code> 中新增 dependency</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.9.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="properties-檔案設定"><a href="#properties-檔案設定" class="headerlink" title="properties 檔案設定"></a><code>properties</code> 檔案設定</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 調整資料庫設定，加上ENC()，方法內填上加密後的字串</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/mytest?serverTimezone=Asia/Taipei&amp;characterEncoding=utf-8</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=ENC(I4gM5/FpHfeA7fW1fioYgBRjZRG5nHl1WEJhDbgm28YFgpndkb1HQR+846TrAFJt)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 配置啟動參數，服務啟動時，需將加密後的字串透過這把Key解密</span><br><span class="line">jasypt.encryptor.password=EbfYkitulv73I2p0mXI50JMXoaxZTKJ7</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>jasypt</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Postman 讀檔進行測試或建立測試資料</title>
    <url>/Postman/20240708/1059746845/</url>
    <content><![CDATA[<p>首先，準備要測試的三個東西<br>1.API request<br>2.環境設定檔<br>3.要讀取的 CSV 檔案</p><p>以下分為四個步驟說明：</p><a id="more"></a>

<h2 id="API-request"><a href="#API-request" class="headerlink" title="API request"></a>API request</h2><h3 id="設定API的-request-URL-跟-request-Body"><a href="#設定API的-request-URL-跟-request-Body" class="headerlink" title="設定API的 request URL 跟 request Body"></a>設定API的 request URL 跟 request Body</h3><p>Request URL 環境別跟Body 參數調整為讀取環境參數檔</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Request URL</span><br><span class="line">&#123;&#123;hostname&#125;&#125;/apim/simulator?name=save</span><br><span class="line"></span><br><span class="line">// Request Body</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;&#123;&#123;name&#125;&#125;&quot;,</span><br><span class="line">    &quot;memoColumn&quot;: &quot;&#123;&#123;memo&#125;&#125;&quot;,</span><br><span class="line">    &quot;custId&quot;: &quot;&#123;&#123;custId&#125;&#125;&quot;,</span><br><span class="line">    &quot;jsonData&quot;: &#123;&#123;responseJson&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>設定後內容，如下圖：<br><img src="/images/postman-read-csv-for-muti-request/1.png" alt></p>
<h3 id="設定Pre-request-Script"><a href="#設定Pre-request-Script" class="headerlink" title="設定Pre-request Script"></a>設定Pre-request Script</h3><p>設定呼叫API前的前置作業，這邊設定逐筆讀取 CSV 檔案的內容並設定到環境參數檔中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//逐次讀出csv的值</span><br><span class="line">let custId = pm.iterationData.get(&quot;custId&quot;);</span><br><span class="line">let name = pm.iterationData.get(&quot;name&quot;);</span><br><span class="line">let memo = pm.iterationData.get(&quot;memo&quot;);</span><br><span class="line">let responseJson = pm.iterationData.get(&quot;responseJson&quot;);</span><br><span class="line"></span><br><span class="line">//將值放到變數</span><br><span class="line">pm.collectionVariables.set(&quot;custId&quot;, custId);</span><br><span class="line">pm.collectionVariables.set(&quot;name&quot;, name);</span><br><span class="line">pm.collectionVariables.set(&quot;memo&quot;, memo);</span><br><span class="line">pm.collectionVariables.set(&quot;responseJson&quot;, responseJson);</span><br></pre></td></tr></table></figure>

<h3 id="設定-Tests"><a href="#設定-Tests" class="headerlink" title="設定 Tests"></a>設定 Tests</h3><p>可以用來撰寫測試案例，但在這次建立測資中不需要，所以這邊只單純印出每次讀到的資料，以確認讀到資料是否正確。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm.collectionVariables.get(&quot;custId&quot;)</span><br><span class="line">console.log(&quot;custId&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="環境參數檔設定"><a href="#環境參數檔設定" class="headerlink" title="環境參數檔設定"></a>環境參數檔設定</h2><p>設定了URL跟Request Body有用到的參數，如下圖：<br><img src="/images/postman-read-csv-for-muti-request/2.png" alt></p>
<h2 id="準備-CSV-檔案"><a href="#準備-CSV-檔案" class="headerlink" title="準備 CSV 檔案"></a>準備 CSV 檔案</h2><p><img src="/images/postman-read-csv-for-muti-request/3.png" alt><br>CSV 檔使用 notepad++ 打開像會是這樣</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 範例</span><br><span class="line">No,custId,name,memo,responseJson</span><br><span class="line">1,1003124838,姓名1,測試資料,&#123;data: null&#125;</span><br><span class="line">2,1003124000,姓名2,測試資料,&#123;data: null&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Collection-Runner-操作方法"><a href="#Collection-Runner-操作方法" class="headerlink" title="Collection Runner 操作方法"></a>Collection Runner 操作方法</h2><h3 id="Collection-Runner-入口"><a href="#Collection-Runner-入口" class="headerlink" title="Collection Runner 入口"></a>Collection Runner 入口</h3><p><img src="/images/postman-read-csv-for-muti-request/4.png" alt></p>
<h3 id="Collection-Runner-操作介面"><a href="#Collection-Runner-操作介面" class="headerlink" title="Collection Runner 操作介面"></a>Collection Runner 操作介面</h3><p><img src="/images/postman-read-csv-for-muti-request/5.png" alt></p>
<ol>
<li>首先，需要先選擇 Collection 以及需要呼叫的API</li>
<li>設定 Environment，選擇剛剛設定好的環境參數檔</li>
<li>Iterations 設定要執行的次數，由於檔案裡的資料只需要執行一次，所以這邊設定1</li>
<li>Delay：每個交易間要延遲多久</li>
<li>Data：選擇要讀取的檔案</li>
<li>設定完成後，就可以點擊下方[Run] button了</li>
</ol>
]]></content>
      <categories>
        <category>Postman</category>
      </categories>
      <tags>
        <tag>Postman</tag>
        <tag>測試</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 停用 Index</title>
    <url>/SQL/20240527/4228458498/</url>
    <content><![CDATA[<h2 id="Oracle-停用-Index"><a href="#Oracle-停用-Index" class="headerlink" title="Oracle 停用 Index"></a>Oracle 停用 Index</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER INDEX SCHEMA_NAME.INDEX_NAME INVISIBLE;  --暫停使用</span><br><span class="line">ALTER INDEX SCHEMA_NAME.INDEX_NAME VISIBLE;  --恢復使用</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>Database</tag>
        <tag>Oracle</tag>
        <tag>SQL</tag>
        <tag>Index</tag>
      </tags>
  </entry>
  <entry>
    <title>ORA-02429 cannot drop index used for enforcement of unique/primary key.</title>
    <url>/SQL/20240526/3488511764/</url>
    <content><![CDATA[<h2 id="ORA-02429-cannot-drop-index-used-for-enforcement-of-unique-primary-key"><a href="#ORA-02429-cannot-drop-index-used-for-enforcement-of-unique-primary-key" class="headerlink" title="ORA-02429: cannot drop index used for enforcement of unique/primary key."></a>ORA-02429: cannot drop index used for enforcement of unique/primary key.</h2><a id="more"></a><p>刪除index時，出現錯誤訊息 ORA-02429: cannot drop index used for enforcement of unique/primary key.</p>
<p>要刪除的index 上面有相依的Constraint(primary key)</p>
<p>原因是在建立primary key時，使用了Using Index將primary key綁定在index上<br>舉例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE  table_name ADD CONSTRAINT pk_key  PRIMARY KEY (&quot;columnName&quot;)</span><br><span class="line">  USING INDEX  index_name  ENABLE;</span><br></pre></td></tr></table></figure>

<p>若要刪除這個 index 的話需要先移除這個Constraint，再刪除index就可以了。<br>解法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name DROP CONSTRAINT pk_key DROP INDEX;</span><br></pre></td></tr></table></figure>

<p>參考連結：</p>
<ol>
<li>如何理解 Using INDEX <a href="https://blog.csdn.net/w892824196/article/details/89510942" target="_blank" rel="noopener">https://blog.csdn.net/w892824196/article/details/89510942</a></li>
</ol>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>Database</tag>
        <tag>Oracle</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>使用8BitDo Zero 2 做為Kobo Clara 2E 藍芽翻頁器</title>
    <url>/%E9%9B%BB%E5%AD%90%E6%9B%B8%E9%96%B1%E8%AE%80%E5%99%A8/20231105/2226902013/</url>
    <content><![CDATA[<p>Kobo Clara 2E 沒有實體鍵，所以翻頁只能靠點擊螢幕。在社群上看到很多人分享外接藍芽翻頁器來翻頁，所以就也買了一個看得順眼的藍芽翻頁器 8BitDo Zero !!但是 Kobo Clara 2E 本身無法直接連結到8BitDo Zero，所以要安裝KoboRoot.tgz，目的是需要它幫忙做按鍵對應，以下是詳細操作步驟。</p><a id="more"></a>
<h2 id="8BitDo-Zero-2"><a href="#8BitDo-Zero-2" class="headerlink" title="8BitDo Zero 2"></a>8BitDo Zero 2</h2><p>充電孔是 usbC 的．盒子裡有附上一條短短的充電線以及矽膠手掛繩<br><img src="/images/8BitDo-Zero-2/1-1.png" alt></p>
<p>購買管道： <a href="https://shope.ee/8KOeRd9n1y" target="_blank" rel="noopener">8BitDo Zero 2 </a></p>
<h2 id="kobo-btpt-安裝教學"><a href="#kobo-btpt-安裝教學" class="headerlink" title="kobo-btpt  安裝教學"></a>kobo-btpt  安裝教學</h2><h3 id="Step1-先去下載開源專案KoboRoot-tgz"><a href="#Step1-先去下載開源專案KoboRoot-tgz" class="headerlink" title="Step1: 先去下載開源專案KoboRoot.tgz"></a>Step1: 先去下載開源專案KoboRoot.tgz</h3><p>下載目前最新的版本（寫文章的當下是v0.0.2）<br><a href="https://github.com/tsowell/kobo-btpt/releases/tag/v0.0.2" target="_blank" rel="noopener">https://github.com/tsowell/kobo-btpt/releases/tag/v0.0.2</a><br><img src="/images/8BitDo-Zero-2/2.png" alt></p>
<h3 id="Step2-將閱讀器連接到電腦上並開啟可以看到隱藏資料夾的設定"><a href="#Step2-將閱讀器連接到電腦上並開啟可以看到隱藏資料夾的設定" class="headerlink" title="Step2 : 將閱讀器連接到電腦上並開啟可以看到隱藏資料夾的設定"></a>Step2 : 將閱讀器連接到電腦上並開啟可以看到隱藏資料夾的設定</h3><p>連接後閱讀器會問你是否要連結到電腦以管理檔案<br>請點連接，就可以在電腦看到kobo的資料夾</p>
<h3 id="Step3-開啟可以看到隱藏資料夾的設定（如果已開啟，可以跳過這個步驟）"><a href="#Step3-開啟可以看到隱藏資料夾的設定（如果已開啟，可以跳過這個步驟）" class="headerlink" title="Step3:開啟可以看到隱藏資料夾的設定（如果已開啟，可以跳過這個步驟）"></a>Step3:開啟可以看到隱藏資料夾的設定（如果已開啟，可以跳過這個步驟）</h3><p>如果是第一次進來的話可能看不到隱藏的資料夾，會像下圖：<br><img src="/images/8BitDo-Zero-2/3.png" alt></p>
<p>如果是mac的話可以打開電腦的「Finder」，並選擇任何可能有隱藏檔案的資料夾。<br>同時按住鍵盤的「Shift」+「Command」+「.」 鍵。<br>此時，你就會看到所有的隱藏檔案名稱顯示半透明狀態。<br><img src="/images/8BitDo-Zero-2/4.png" alt></p>
<h3 id="Step4-把step1下載的-KoboRoot-tgz放到「-kobo」資料夾，然後退出閱讀器，退出後閱讀器會重新開機"><a href="#Step4-把step1下載的-KoboRoot-tgz放到「-kobo」資料夾，然後退出閱讀器，退出後閱讀器會重新開機" class="headerlink" title="Step4: 把step1下載的 KoboRoot.tgz放到「.kobo」資料夾，然後退出閱讀器，退出後閱讀器會重新開機"></a>Step4: 把step1下載的 KoboRoot.tgz放到「.kobo」資料夾，然後退出閱讀器，退出後閱讀器會重新開機</h3><h3 id="Step5-下載指令檔-8BitDo-Zero-2-gamepad"><a href="#Step5-下載指令檔-8BitDo-Zero-2-gamepad" class="headerlink" title="Step5: 下載指令檔 8BitDo Zero 2 gamepad"></a>Step5: 下載指令檔 8BitDo Zero 2 gamepad</h3><p>下載路徑：<br><a href="https://github.com/tsowell/kobo-btpt/blob/main/examples/8BitDo%20Zero%202%20gamepad" target="_blank" rel="noopener">https://github.com/tsowell/kobo-btpt/blob/main/examples/8BitDo%20Zero%202%20gamepad</a></p>
<p>點擊此處下載鍵，就會下載一個副檔名是 .txt 的檔案<br><img src="/images/8BitDo-Zero-2/5.png" alt></p>
<h3 id="Step6-閱讀器重新開機後，再重新連結到電腦上，打開後會到多一個隱藏資料夾「-btpt」"><a href="#Step6-閱讀器重新開機後，再重新連結到電腦上，打開後會到多一個隱藏資料夾「-btpt」" class="headerlink" title="Step6: 閱讀器重新開機後，再重新連結到電腦上，打開後會到多一個隱藏資料夾「.btpt」"></a>Step6: 閱讀器重新開機後，再重新連結到電腦上，打開後會到多一個隱藏資料夾「.btpt」</h3><p><img src="/images/8BitDo-Zero-2/6.png" alt></p>
<h3 id="Step7-把step4下載的8BitDo-Zero-2-gamepad放到「-btpt」資料夾，並調整副檔名"><a href="#Step7-把step4下載的8BitDo-Zero-2-gamepad放到「-btpt」資料夾，並調整副檔名" class="headerlink" title="Step7: 把step4下載的8BitDo Zero 2 gamepad放到「.btpt」資料夾，並調整副檔名"></a>Step7: 把step4下載的8BitDo Zero 2 gamepad放到「.btpt」資料夾，並調整副檔名</h3><p>這邊要特別注意檔名以及副檔名<br>如果副檔名是.txt的話，開啟閱讀器時會看到一份txt文件檔，必須調整副檔名<br>調整副檔名的方法，以 mac 操作的話，對檔案點擊右鍵後選「取得資訊」，去除後方的.txt<br><img src="/images/8BitDo-Zero-2/7.png" alt></p>
<p>成功的話會看到一個執行檔<br><img src="/images/8BitDo-Zero-2/8.png" alt></p>
<h3 id="Step8-退出閱讀器並重新開機"><a href="#Step8-退出閱讀器並重新開機" class="headerlink" title="Step8: 退出閱讀器並重新開機"></a>Step8: 退出閱讀器並重新開機</h3><h3 id="Step9-與8BitDo-Zero-2配對"><a href="#Step9-與8BitDo-Zero-2配對" class="headerlink" title="Step9: 與8BitDo Zero 2配對"></a>Step9: 與8BitDo Zero 2配對</h3><p>開機後到藍芽設定頁面連接8BitDo Zero 2 gamepad，同時讓 8BitDo Zero 2 進入藍芽配對模式<br>按下8BitDo Zero 2 的 X 鍵及 start 鍵，進入 X-Input 模式閃後，然後長按 select 鍵進入藍牙配對模式。</p>
<p>若配對成功後，可以任一開啟一本書試看看能不能翻頁回，如果不行就在藍牙設定畫面忘記裝置再重新配對一次。<br>配對成功的話，就可以用這個可愛的藍芽翻頁器看書囉 ~</p>
<p>參考網址：<a href="https://github.com/tsowell/kobo-btpt" target="_blank" rel="noopener">https://github.com/tsowell/kobo-btpt</a></p>
]]></content>
      <categories>
        <category>電子書閱讀器</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>電子書閱讀器</tag>
        <tag>閱讀</tag>
        <tag>藍芽翻頁器</tag>
        <tag>Kobo</tag>
      </tags>
  </entry>
  <entry>
    <title>電子書閱讀器 讀墨 mooink plus 2 使用一年心得</title>
    <url>/%E9%9B%BB%E5%AD%90%E6%9B%B8%E9%96%B1%E8%AE%80%E5%99%A8/20230903/760969821/</url>
    <content><![CDATA[<h2 id="我是如何挑選電子書閱讀器"><a href="#我是如何挑選電子書閱讀器" class="headerlink" title="我是如何挑選電子書閱讀器"></a>我是如何挑選電子書閱讀器</h2><p>電子書閱讀器分開放式跟封閉式</p><ul>
<li>封閉式閱讀器：只能使用該家閱讀器內建的功能</li>
<li>開放式閱讀器：可以想像成是一台Android手機，可以下載各家電子書平台的App使用，也就是可以用來看kobo/readmoo/MyBook/Hami Book/Hyread各大圖書館借閱</li>
</ul><a id="more"></a>

<p>你會說這樣不是選開放式閱讀器就好了嗎？所有願望一次滿足</p>
<p>不過有利就有弊，封閉式閱讀器的翻頁或功能跳轉也比較流暢，介面的操作上也比較容易，新手較推薦封閉式閱讀器，可以減少入手門檻。所以在挑選我的第一台閱讀器的時候我就先不考慮開放式閱讀器</p>
<p>以kobo、mooink 跟kindle 三個品牌來挑選<br>以下是我考量的點</p>
<ul>
<li>Kindle：<br>聽說很耐用，朋友用了好幾年都不壞<br>不過amazon 上的中文書較少，我比較常看中文書<br>如果在別的平台買書，還需手動匯入，就先不考慮</li>
<li>Kobo：<br>中文書也蠻多的，但我覺得kobo官網選書畫面很不適合閒逛，分類太少</li>
<li>mooink ：<br>繁體中文書選擇較多。常常舉辦活動，會有一些折扣或是特定主題的閱讀馬拉松</li>
</ul>
<h2 id="mooink-plus-2-7-8吋-外觀"><a href="#mooink-plus-2-7-8吋-外觀" class="headerlink" title="mooink plus 2 7.8吋 外觀"></a>mooink plus 2 7.8吋 外觀</h2><p>最後，我選了讀墨 mooink plus 2 7.8吋<br>閱讀器本體外我也買了讀墨原廠的直立式保護套<br>是下面這一個組合<br><a href="https://moo.im/a/7cdsIU" target="_blank" rel="noopener">7.8 吋 mooInk Plus 2 電子書閱讀器＋直掀式保護殼－楓木棕
</a></p>
<p>實物照<br>正面：<br><img src="https://imgur.com/HPSro8S.png" alt></p>
<p>反面：<br><img src="https://imgur.com/QUzEMzP.png" alt></p>
<p>使用原廠皮套：<br><img src="https://imgur.com/EwwtF2b.png" alt><br><img src="https://imgur.com/BTYh70c.png" alt></p>
<p>充電孔：<br><img src="https://imgur.com/5EM1haK.png" alt></p>
<h2 id="mooink-plus-2-7-8吋-使用心得"><a href="#mooink-plus-2-7-8吋-使用心得" class="headerlink" title="mooink plus 2 7.8吋 使用心得"></a>mooink plus 2 7.8吋 使用心得</h2><p>來説説使用mooink plus 2 一年後的心得：</p>
<ul>
<li>兩側有實體翻頁鍵（左右兩側各2個，共4個），想用哪一隻手拿都可以。</li>
<li>有流式書籍橫／直排一鍵轉換功能。通常翻譯小說會是直式的，如果看不習慣就可以轉換成自己習慣的橫式。</li>
<li>有前導閱讀燈（搭載雙色燈、色溫調整功能），可以調整成黃光或是藍光兩種，在燈光不夠充足的地方也可以開閱讀燈看書。</li>
<li>在電量體驗上，在不開藍牙跟網路的狀態下，一天看一個小時的狀態下，可以兩三個禮拜才充電一次。</li>
<li>在購入一段時間後，出了一個新功能是省電模式，如果在看書的狀態下，閱讀器會關掉自動關掉網路，更加省電了。</li>
<li>空機重量260g，保護殼222g，兩個加起來有482g。如果是通勤或是隨身攜帶，其實偏重，因為機身7.8吋以一個女生的手其實是無法單手掌握的。</li>
<li>mooink plus 2的充電孔在下方，充電時會卡到原廠的直掀式保護殼無法將皮套關上</li>
<li>最後跟閱讀器本身無關的：<ul>
<li>讀墨有App網頁跟網頁，所以忘記帶閱讀器出門也可以透過手機來看書,只要有連上網路，各個裝置間的閱讀進度都可以同步。</li>
<li>讀墨有個「文件」功能，可以透過上傳epub、pdf、 doc與txt檔案，所以也可以在kobo上買書mooink上看。也可以透過網址上傳文件，用閱讀器看文字的網頁小說。</li>
</ul>
</li>
</ul>
<p>如果喜歡我的分享<br>也可以透過我的讀墨AP連結購買讀墨的閱讀器，謝謝</p>
<p>7.8 吋 mooInk Plus 2 電子書閱讀器<br><a href="https://moo.im/a/7cdsIU" target="_blank" rel="noopener">https://moo.im/a/7cdsIU</a></p>
<p>7.8 吋 mooInk Plus 2C 彩色電子書閱讀器<br><a href="https://moo.im/a/9chFHQ" target="_blank" rel="noopener">https://moo.im/a/9chFHQ</a></p>
<p>6 吋 mooInk S 電子書閱讀器－硯墨黑<br><a href="https://moo.im/a/6euFRY" target="_blank" rel="noopener">https://moo.im/a/6euFRY</a></p>
]]></content>
      <categories>
        <category>電子書閱讀器</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>電子書閱讀器</tag>
        <tag>閱讀</tag>
      </tags>
  </entry>
  <entry>
    <title>DBeaver 連本機 MySQL server 遇到 Public Key Retrieval is not allowed</title>
    <url>/SQL/20230425/4002286829/</url>
    <content><![CDATA[<p>解決方法：<br>修改Driver的設定才能讓JDBC順利連線到資料庫。</p><p>修改方式<br>Step1:編輯連線<br><img src="https://i.imgur.com/BEqDBQH.png" alt></p><p>Step2:選到driver的部分，將allowPublicKeyRetrieval 設為TRUE後，測試連線，即可連線成功<br><img src="https://i.imgur.com/KruMczz.png" alt></p><a id="more"></a>


<p><img src="https://i.imgur.com/Wk7W7gW.png" alt></p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>複製同一個table 欄位A的值到欄位B</title>
    <url>/SQL/20211101/3569669284/</url>
    <content><![CDATA[<h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><p>如標題<br>舉例 想把customer table的欄位name 複製到secondName<br><img src="https://i.imgur.com/9uBEINM.png" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Customer</span><br><span class="line">(</span><br><span class="line">    id   INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(30),</span><br><span class="line">    secondName VARCHAR(30)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><a id="more"></a>


<h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><p>以下使用MySQL進行測試</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update Customer set secondName = name where name is not null</span><br></pre></td></tr></table></figure>

<h6 id="tags-sql-db"><a href="#tags-sql-db" class="headerlink" title="tags: sql db"></a>tags: <code>sql</code> <code>db</code></h6>]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>解決Github push 身份驗證失敗</title>
    <url>/git/20211001/714155446/</url>
    <content><![CDATA[<h2 id="出現狀況"><a href="#出現狀況" class="headerlink" title="出現狀況"></a>出現狀況</h2><p><img src="https://i.imgur.com/xLAZcLr.png" alt></p><h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><h3 id="產生ssh-key"><a href="#產生ssh-key" class="headerlink" title="產生ssh key"></a>產生ssh key</h3><p>指令可以參考之前處理<a href="https://sinyilin.github.io/git/20191024/1014042378/">Github新增SSH Key</a>的文章</p><p>不同的地方在於設定的網頁不同，重點就是要將 id_rsa.pub 的內容提供給伺服器。</p><a id="more"></a>


<h3 id="在GitHub設定SSH-Key"><a href="#在GitHub設定SSH-Key" class="headerlink" title="在GitHub設定SSH Key"></a>在GitHub設定SSH Key</h3><p>1.點選右上角的選單，選擇「Settings」<br><img src="https://i.imgur.com/Exs5f8a.png" alt></p>
<p>2.左邊選單選擇「SSH and GPG keys」後點選「New SSH keys」<br><img src="https://i.imgur.com/eW27Is8.png" alt></p>
<p>3.填寫Title (可識別就好)以及把剛剛複製的那串SSH key貼上即可。<br><img src="https://i.imgur.com/98Q6z62.png" alt></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 將 A table的資料複製到 B table</title>
    <url>/SQL/20210513/1337088916/</url>
    <content><![CDATA[<p>如題，假設目前要將個人資料(Person)複製到客戶資料表(Customer)應該要怎麼做呢？</p><p>以下使用這個網站來進行SQL的測試，這個網站支援很多種類型的資料庫<br><a href="http://sqlfiddle.com/" target="_blank" rel="noopener">http://sqlfiddle.com/</a></p><a id="more"></a>

<h2 id="Create-Table"><a href="#Create-Table" class="headerlink" title="Create Table"></a>Create Table</h2><p>DDL Create Table</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Person (</span><br><span class="line">  National_Id varchar(12),</span><br><span class="line">  Name varchar(50),</span><br><span class="line">  Address varchar(255),</span><br><span class="line">  Phone varchar(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE Customer (</span><br><span class="line">  Cust_Id varchar(12),</span><br><span class="line">  Lvl varchar(2),</span><br><span class="line">  Name varchar(50),</span><br><span class="line">  Address varchar(255),</span><br><span class="line">  Phone varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="建測試資料"><a href="#建測試資料" class="headerlink" title="建測試資料"></a>建測試資料</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO Person (National_Id, Name, Address, Phone)</span><br><span class="line">VALUES (&apos;A123456789&apos;, &apos;YOYO&apos;, &apos;OO路300號&apos;, &apos;12345678&apos;);</span><br></pre></td></tr></table></figure>

<p>如圖，DDL Script跟insert SQL寫在左邊<br><img src="https://i.imgur.com/3tjoHvw.png" alt></p>
<p>如此一來就會建立兩張table，並在Person table中加入一筆資料</p>
<p>右邊是查詢語句，下面是結果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from Person;</span><br><span class="line">select * from Customer;</span><br></pre></td></tr></table></figure>

<h2 id="複製資料"><a href="#複製資料" class="headerlink" title="複製資料"></a>複製資料</h2><p>將A table的資料複製到B table，可以將insert跟select組在一起，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO Customer (Cust_Id, Lvl ,Name, Address, Phone)</span><br><span class="line">SELECT National_Id,&apos;L1&apos;,Name, Address, Phone FROM Person;</span><br></pre></td></tr></table></figure>

<p>查看結果，資料已成功複製過去<br><img src="https://i.imgur.com/NwB1Cyz.png" alt></p>
<p>不過這個寫法僅限於B table已存在的狀態下</p>
<p>如果是B table不存在的話，可以這樣做</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table Customer as</span><br><span class="line">SELECT National_Id,Name, Address, Phone FROM Person;</span><br></pre></td></tr></table></figure>

<p>執行結果如圖<br><img src="https://i.imgur.com/psi687x.png" alt></p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ol>
<li>SQL Fiddle 使用教學<a href="https://www.jinnsblog.com/2013/09/sql-fiddle-test-sql-syntax-online.html" target="_blank" rel="noopener">https://www.jinnsblog.com/2013/09/sql-fiddle-test-sql-syntax-online.html</a></li>
<li>Create table DDL <a href="https://www.fooish.com/sql/create-table.html" target="_blank" rel="noopener">https://www.fooish.com/sql/create-table.html</a></li>
<li>兩種複製資料的做法<a href="https://stackoverflow.com/questions/2250196/select-into-using-oracle" target="_blank" rel="noopener">https://stackoverflow.com/questions/2250196/select-into-using-oracle</a></li>
</ol>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>SQL</tag>
        <tag>Insert</tag>
        <tag>Copy</tag>
      </tags>
  </entry>
  <entry>
    <title>換台電腦重新建置寫hexo blog 環境</title>
    <url>/hexo/20200308/3746848229/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>要做這件事的前提是要有備份之前的原始檔，被push上去github的已經是編譯過後的檔案，<del>所以沒有留原始檔，大概就是沒救了</del></p><a id="more"></a>
<h2 id="檢查電腦環境設定"><a href="#檢查電腦環境設定" class="headerlink" title="檢查電腦環境設定"></a>檢查電腦環境設定</h2><p>首先，要先檢查環境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 檢查 是否有安裝git</span><br><span class="line">$ git --version</span><br><span class="line"></span><br><span class="line"># 檢查是否有安裝node.js</span><br><span class="line">$ node -v</span><br><span class="line"></span><br><span class="line"># 檢查是否有安裝hexo</span><br><span class="line">$ hexo -v</span><br></pre></td></tr></table></figure>

<h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><p>接續這篇文的 各種安裝<br><a href="https://sinyilin.github.io/hexo/20190924/3166793059/">https://sinyilin.github.io/hexo/20190924/3166793059/</a></p>
<ul>
<li>安裝 Hexo</li>
<li>安裝 Hexo Git</li>
<li>初始化 Hexo =&gt;只做如下指令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init blog  #會建立一個blog資料夾</span><br><span class="line">$ cd blog   #進入該資料夾</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="將先前備份的檔案複製至新環境"><a href="#將先前備份的檔案複製至新環境" class="headerlink" title="將先前備份的檔案複製至新環境"></a>將先前備份的檔案複製至新環境</h2><p>接著將之前備份的blog資料放到新建裡的blog下<br>下圖為我上一台電腦的備份blog資料夾內容<br><img src="https://i.imgur.com/DCorjQ5.png" alt></p>
<p>我的做法是將除了node_modules跟public外的檔案都複製過去<br>因node_modules是放一些lib的地方，執行npm install時就會下載相關的lib；public是放原始檔編譯後的file<br>所以這兩個都不用複製過去</p>
<p>複製過去後，執行如下指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install</span><br><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">$ npm install hexo-generator-feed --save</span><br><span class="line">$ npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>

<h2 id="檢視"><a href="#檢視" class="headerlink" title="檢視"></a>檢視</h2><p>可以先執行一下，以下指令，看看在本機看看網站有沒有各種毀滅</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo s --debug</span><br><span class="line"># 可以透過本機的 http://localhost:4000 查看結果</span><br></pre></td></tr></table></figure>

<p>沒有的話再push回github.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#重新部署</span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure>

<h2 id="解決部署問題"><a href="#解決部署問題" class="headerlink" title="解決部署問題"></a>解決部署問題</h2><p>不過部署時遇到另外一個問題 Error: Spawn failed<br><img src="https://i.imgur.com/w3VU4Xu.png" alt></p>
<p>參考了這篇<a href="https://github.com/hexojs/hexo/issues/3043" target="_blank" rel="noopener">https://github.com/hexojs/hexo/issues/3043</a><br>先採取先升級git版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># for mac upgrade git version</span><br><span class="line">$ brew upgrade git</span><br></pre></td></tr></table></figure>

<p>upgrade 時有遇到一點問題，照著他給你的指示執行就可以升級了<br><img src="https://i.imgur.com/6LOfVCq.png" alt></p>
<p>接下來輸入完帳號密碼後，就能成功部署上去了<br><img src="https://i.imgur.com/mhRKJGe.png" alt></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>設定 Hexo 主題 next 右上角的 Github 樣式</title>
    <url>/hexo/20191109/1819073706/</url>
    <content><![CDATA[<p>目標是加上在 Blog 右上角加上這個</p><p><img src="https://i.imgur.com/sZ4aqy0.png" alt></p><p>首先，先在這邊找到一個自己喜歡的樣式，並複製出來。 <a href="http://tholman.com/github-corners/#" target="_blank" rel="noopener">http://tholman.com/github-corners/#</a><br>然後將 <code>href</code> 修改為自己的 Github 網址</p><a id="more"></a>


<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://your-url"</span> <span class="attr">class</span>=<span class="string">"github-corner"</span> <span class="attr">aria-label</span>=<span class="string">"View source on GitHub"</span>&gt;</span><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"80"</span> <span class="attr">height</span>=<span class="string">"80"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 250 250"</span> <span class="attr">style</span>=<span class="string">"fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"</span> <span class="attr">fill</span>=<span class="string">"currentColor"</span> <span class="attr">style</span>=<span class="string">"transform-origin: 130px 106px;"</span> <span class="attr">class</span>=<span class="string">"octo-arm"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"</span> <span class="attr">fill</span>=<span class="string">"currentColor"</span> <span class="attr">class</span>=<span class="string">"octo-body"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"><span class="selector-class">.github-corner</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.octo-arm</span>&#123;<span class="attribute">animation</span>:octocat-wave <span class="number">560ms</span> ease-in-out&#125;@<span class="keyword">keyframes</span> octocat-wave&#123;0%,100%&#123;<span class="attribute">transform</span>:<span class="built_in">rotate</span>(0)&#125;20%,60%&#123;<span class="attribute">transform</span>:<span class="built_in">rotate</span>(-25deg)&#125;40%,80%&#123;<span class="attribute">transform</span>:<span class="built_in">rotate</span>(10deg)&#125;&#125;@<span class="keyword">media</span> (max-width:<span class="number">500px</span>)&#123;<span class="selector-class">.github-corner</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.octo-arm</span>&#123;<span class="attribute">animation</span>:none&#125;<span class="selector-class">.github-corner</span> <span class="selector-class">.octo-arm</span>&#123;<span class="attribute">animation</span>:octocat-wave <span class="number">560ms</span> ease-in-out&#125;&#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果是想將這個圖示只放在首頁上的話，就在 <code>themes/next/index.swig</code> 中貼上後重新部署。<br><img src="https://i.imgur.com/gARRGk4.png" alt></p>
<p>如果是每一頁都要放的話就要放在<code>themes/next/layout/_layout.swig</code> 的<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code> 後，一樣貼上後重新部署。<br><img src="https://i.imgur.com/FOOSIrJ.png" alt></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Git - 忽略特定檔案 .gitignore</title>
    <url>/git/20191109/1510464038/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近接手外包廠商的 code ，看別人的 code 怎麼寫的總是會有一些意外的收穫，也順便複習一下之前遇過的問題，並把它記錄下來。</p><a id="more"></a>
<p>第一個遇到的問題就是當我修改完成 code 準備要 commit 時，發現 Git 追蹤(track)了一些不應該 push 到 remote repository的東西。<br>像是 IntelliJ IDE的一些檔案或是 log 等的東西，所以我決定加個<code>.gitignore</code></p>
<p><img src="https://i.imgur.com/WR8E0CY.png" alt></p>
<h2 id="加入-gitignore"><a href="#加入-gitignore" class="headerlink" title="加入.gitignore"></a>加入<code>.gitignore</code></h2><p>STEP1. 新增<code>.gitignore</code> 檔案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ touch .gitignore</span><br></pre></td></tr></table></figure>

<p>STEP2. 設定要忽略的檔案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## idea</span><br><span class="line">.idea/*.xml</span><br><span class="line">.idea/.name</span><br><span class="line"></span><br><span class="line">## log</span><br><span class="line">logs/</span><br></pre></td></tr></table></figure>

<p>像我這樣設定的話就是忽略idea目錄下<code>.xml</code>與<code>.name</code>結尾的檔案，以及忽略<code>log</code>目錄下的所有東西。</p>
<h2 id="結果"><a href="#結果" class="headerlink" title="結果"></a>結果</h2><p>在新增<code>.gitignore</code> 這個過濾條件後新增的檔案，如果符合上面的的規則就 Git 就不會去追蹤他</p>
<p>但在新增<code>.gitignore</code> 這個過濾條件前新增的檔案，因為快取的關係，如果沒有額外處理的話還是會被追蹤。</p>
<h2 id="處理新增-gitignore-這個過濾條件前新增的檔案"><a href="#處理新增-gitignore-這個過濾條件前新增的檔案" class="headerlink" title="處理新增.gitignore 這個過濾條件前新增的檔案"></a>處理新增<code>.gitignore</code> 這個過濾條件前新增的檔案</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 清除本機 Git 的快取，相當於將所有檔案移除 Git 的追蹤，但沒有刪除檔案</span><br><span class="line">$ git rm -r --cached .</span><br><span class="line"></span><br><span class="line"># 重新加入 Git 追縱，這時會套用 .gitignore 設定</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># commit上去時會忽略那些設定在 .gitignore 的檔案</span><br><span class="line">$ git commit -m &apos;update .gitignore&apos;</span><br></pre></td></tr></table></figure>

<h2 id="透過-SourceTree-處理新增-gitignore-這個過濾條件前新增的檔案"><a href="#透過-SourceTree-處理新增-gitignore-這個過濾條件前新增的檔案" class="headerlink" title="透過 SourceTree 處理新增 .gitignore 這個過濾條件前新增的檔案"></a>透過 SourceTree 處理新增 <code>.gitignore</code> 這個過濾條件前新增的檔案</h2><p>如果不想執行指令的話，可以透過工具 SourceTree 修改 .gitignore，也可以達成一樣的效果</p>
<p>1.假設 .project 這個檔案不想被追蹤，可從路徑 Settings &gt; Advanced 來調整 Repository-specfic ignore list的 <code>.gitignore</code> 檔案<br><img src="/images/git-01-gitignore/1.png" alt><br><img src="/images/git-01-gitignore/2.png" alt></p>
<p>2.儲存後 設定會立即生效，可以看到.project 檔已經不被git 追蹤<br><img src="/images/git-01-gitignore/3.png" alt></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>除了我在這個狀況裡遇到的那些不想被 push 到 remote repository的東西外，一般也不會把機密資料、java編譯後的檔案(target目錄下的東西)與編輯器的檔案等給放上去。</p>
<p>GitHub 上面也有提供各種專案的 <code>.gitignore</code> 範本，可以參考這個專案進行設定 <a href="https://github.com/github/gitignore" target="_blank" rel="noopener">Github - A collection of useful .gitignore templates</a></p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ol>
<li><a href="https://poychang.github.io/gitignore-and-delete-untracked-files/" target="_blank" rel="noopener">https://poychang.github.io/gitignore-and-delete-untracked-files/</a></li>
<li><a href="https://gitbook.tw/chapters/using-git/ignore.html" target="_blank" rel="noopener">https://gitbook.tw/chapters/using-git/ignore.html</a></li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>在 GitLab 上新增 SSH key</title>
    <url>/git/20191024/1014042378/</url>
    <content><![CDATA[<h2 id="GitLab-上的訊息提示"><a href="#GitLab-上的訊息提示" class="headerlink" title="GitLab 上的訊息提示"></a>GitLab 上的訊息提示</h2><p>因為初次使用GitLab進行code管理<br>但要clone別人code時看到了這個提示</p><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">You won&apos;t be able to pull or push project code via SSH until you add an SSH key to your profile</span><br></pre></td></tr></table></figure>

<p>提示訊息<br><img src="https://i.imgur.com/i3l11Lq.png" alt></p>
<p>為什麼會有這個提示呢？<br>原因是Gitlab每次執行clone、pull、push code等時都要輸入帳號與密碼。如果想要省略掉這個輸入密碼的步驟可以在local端生成SSH key，然後設定到GitLab上。</p>
<h2 id="在local端產生SSH-key"><a href="#在local端產生SSH-key" class="headerlink" title="在local端產生SSH key"></a>在local端產生SSH key</h2><h3 id="STEP1-確認目前的電腦裡是否有id-rsa-pub"><a href="#STEP1-確認目前的電腦裡是否有id-rsa-pub" class="headerlink" title="STEP1. 確認目前的電腦裡是否有id_rsa.pub"></a>STEP1. 確認目前的電腦裡是否有<code>id_rsa.pub</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 指令</span><br><span class="line">$ cd ~/.ssh</span><br><span class="line">$ ls</span><br></pre></td></tr></table></figure>

<h4 id="id-rsa-pub不存在的狀況"><a href="#id-rsa-pub不存在的狀況" class="headerlink" title="id_rsa.pub不存在的狀況"></a><code>id_rsa.pub</code>不存在的狀況</h4><p><img src="https://i.imgur.com/6MXUISK.png" alt></p>
<h4 id="id-rsa-pub存在的狀況"><a href="#id-rsa-pub存在的狀況" class="headerlink" title="id_rsa.pub存在的狀況"></a><code>id_rsa.pub</code>存在的狀況</h4><p><img src="https://i.imgur.com/60Mpgxx.png" alt></p>
<p>如果<code>id_rsa.pub</code>已經存在，那麼你可以跳過STEP2，直接進入STEP3.設定GitLab </p>
<h3 id="STEP2-建SSH-key"><a href="#STEP2-建SSH-key" class="headerlink" title="STEP2. 建SSH key"></a>STEP2. 建SSH key</h3><h4 id="建立指令"><a href="#建立指令" class="headerlink" title="建立指令"></a>建立指令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;yourEmail@example.com</span><br></pre></td></tr></table></figure>

<p>上面參數的含義：<br>– t 指定金鑰型別，預設是 rsa ，可以省略。<br>-C 設定註釋文字，如mail，這邊的mail需要是註冊Gitlab的那個mail。<br>-f 指定金鑰檔案儲存檔名。</p>
<h4 id="SSH-key的儲存路徑"><a href="#SSH-key的儲存路徑" class="headerlink" title="SSH key的儲存路徑"></a>SSH key的儲存路徑</h4><p>由於以上指令沒有 -f 參數。所以，執行完後會讓你輸入一個檔名，用於儲存剛才生成的 SSH key 程式碼，如：<br><img src="https://i.imgur.com/sMgzExv.png" alt><br>檔名可以不輸入</p>
<h4 id="密碼"><a href="#密碼" class="headerlink" title="密碼"></a>密碼</h4><p>接下來是密碼的部分<br>如果沒有要設定驗證密碼，直接按 Enter 就可以產生SSH-key。<br>我這邊不設定密碼，我猜測這個如果設定這個密碼，使用時可能還需要key 密碼。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure>

<h4 id="建立成功"><a href="#建立成功" class="headerlink" title="建立成功"></a>建立成功</h4><p>當你看到以下畫面時，表示SSH key建立成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Your identification has been saved in /Users/dbit/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /Users/dbit/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256: ----</span><br><span class="line">The key&apos;s randomart image is:-----</span><br></pre></td></tr></table></figure>

<h3 id="STEP3-查看-SSH-key"><a href="#STEP3-查看-SSH-key" class="headerlink" title="STEP3. 查看 SSH key"></a>STEP3. 查看 SSH key</h3><p>下指令，然後複製裡面的SSH key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<h2 id="在GitLab上設定"><a href="#在GitLab上設定" class="headerlink" title="在GitLab上設定"></a>在GitLab上設定</h2><ol>
<li><p>點選右上角的選單，選擇「Settings」</p>
</li>
<li><p>左邊選單選擇「SSH key」進入到以下畫面：<br><img src="https://i.imgur.com/UKCKzQF.png" alt></p>
</li>
<li><p>把剛剛複製的那串SSH key貼上與填寫該SSH Key名稱即可。</p>
</li>
<li><p>測試：在local端 <code>git clone (Clone with HTTPS URL)</code>一次時，不用輸入帳號密碼表示成功。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>閱讀CORS(Cross-Origin Resource Sharing)相關文章筆記</title>
    <url>/javascript/20191021/2264764841/</url>
    <content><![CDATA[<h2 id="主要閱讀文章"><a href="#主要閱讀文章" class="headerlink" title="主要閱讀文章"></a>主要閱讀文章</h2><ul>
<li><a href="https://blog.techbridge.cc/2017/05/20/api-ajax-cors-and-jsonp/" target="_blank" rel="noopener">輕鬆理解 Ajax 與跨來源請求</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">HTTP访问控制（CORS）</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></li>
</ul><a id="more"></a>
<h2 id="CORS-MDN解釋"><a href="#CORS-MDN解釋" class="headerlink" title="CORS MDN解釋"></a>CORS <a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS" target="_blank" rel="noopener">MDN</a>解釋</h2><p>跨來源資源共用（Cross-Origin Resource Sharing (CORS)）是一種使用額外 HTTP 標頭令目前瀏覽網站的使用者代理取得存取其他來源（網域）伺服器特定資源權限的機制。當使用者代理請求一個不是目前文件來源——例如來自於不同網域（domain）、通訊協定（protocol）或通訊埠（port）的資源時，會建立一個跨來源 HTTP 請求（cross-origin HTTP request）。</p>
<h2 id="CORS產生原因："><a href="#CORS產生原因：" class="headerlink" title="CORS產生原因："></a>CORS產生原因：</h2><p>瀏覽器基於安全性考量，有同源政策（Same-origin policy）<br>也就是說你想要呼叫與你網站「不同源」的API時，瀏覽器一樣會幫你發request，但會把 Response 擋下來，不讓你的 JavaScript 拿到並且傳回錯誤。<br>何謂「不同源」？<br>我原本的理解是不同IP之類，但是<a href="https://blog.techbridge.cc/2017/05/20/api-ajax-cors-and-jsonp/" target="_blank" rel="noopener">前面的文章</a>中有提到<br>Domain 不一樣就是不同源，或者是一個用http一個用https也是不同源，port不一樣也是不同源。</p>
<h2 id="CORS-Cross-Origin-Resource-Sharing-跨來源資源共享"><a href="#CORS-Cross-Origin-Resource-Sharing-跨來源資源共享" class="headerlink" title="CORS(Cross-Origin Resource Sharing) 跨來源資源共享"></a>CORS(Cross-Origin Resource Sharing) 跨來源資源共享</h2><p>呼叫API很常會遇到不同Domain的API，CORS就是為了解決這個問題。<br>這套規範提到如果你想開啟跨來源 HTTP 請求的話，Server 必須在 Response 的 Header 裡面加上<code>Access-Control-Allow-Origin</code>。<br>Response可以設定<br><code>Access-Control-Allow-Origin: *</code>，設定接受什麼域名的请求，*表示任何的origin都接受。<br><code>Access-Control-Allow-Headers</code>，接受哪些Request Header<br><code>Access-Control-Allow-Methods</code>，限制Method<br>所以說，要發起跨來源 HTTP 請求並且順利收到回應的話，被Request的那一方(Server端)的Response需要在 Header 裡面加上<code>Access-Control-Allow-Origin</code>，才能讓不是同源的網站去call，不然 Response 會被瀏覽器給擋下來並且顯示出錯誤訊息。</p>
<h2 id="CORS-中Request-的分類"><a href="#CORS-中Request-的分類" class="headerlink" title="CORS 中Request 的分類"></a>CORS 中Request 的分類</h2><h3 id="簡單請求（simple-requests）"><a href="#簡單請求（simple-requests）" class="headerlink" title="簡單請求（simple requests）"></a>簡單請求（simple requests）</h3><p>很多種情況符合簡單請求，其中一種就是不使用自定義的 Header(不帶參數)，而且又是 GET 的話。</p>
<h3 id="預檢請求-Preflight-request"><a href="#預檢請求-Preflight-request" class="headerlink" title="預檢請求 (Preflight request)"></a>預檢請求 (Preflight request)</h3><p>會先以 HTTP 的 OPTIONS 方法發request到另一個網域，確認後續真正要發的request是否可安全送出。如果Preflight request沒有通過的話，後續真正要發的request也不會被觸發。</p>
<p>要分辨是哪種的請求的話，可以參考<a href="(https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)">這篇文章</a>，這邊就不多做解釋</p>
<h3 id="為何需要Preflight-request"><a href="#為何需要Preflight-request" class="headerlink" title="為何需要Preflight request?"></a>為何需要Preflight request?</h3><p>使用的情境之一：由於跨站請求可能會攜帶使用者資料，所以要先進行預檢請求。<br>以下例子引用<a href="https://blog.techbridge.cc/2017/05/20/api-ajax-cors-and-jsonp/" target="_blank" rel="noopener">輕鬆理解 Ajax 與跨來源請求</a></p>
<p>如果今天沒有 Preflight Request 這個機制的話，我就可以在隨便一個 Domain 的網頁上面發送一個 DELETE 的 Request 給這個 API。剛剛我有強調說瀏覽器的 CORS 機制，還是會幫你發送 Request，但只是 Response 被瀏覽器擋住而已。<br>因此呢，儘管沒有 Response，但是 Server 端的確收到了這個 Request，因此就會把這筆資料給刪除。<br>如果有 Preflight Request 的話，在發送出去收到結果的時候，就會知道這個 API 並沒有提供 CORS，因此真的 DELETE 請求就不會送出，到這邊就結束了。<br>先用一個 OPTIONS 的請求去確認之後的 Request 能不能送出，這就是 Preflight Request 的目的。</p>
<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p>看到現在內心我有一些疑問，就去發問了</p>
<p>問題1.這兩種方式應該都會做是否同源的檢查？<br>Ans:<br>簡單請求（simple requests）有時候不會觸發同源的檢查<br>預檢請求 (Preflight request) 則會觸發同源的檢查</p>
<p>問題2.因為非簡單請求可能會帶有一些使用者資料，因此會先透過 Preflight Request 去確認後續的請求能否送出。<br>所以說Preflight request中會先用一個 OPTIONS 的請求去確認之後的 Request 能不能送出的這一個 OPTIONS 的請求都是先去檢查使用者是否有權限嗎？<br>Ans:<br>以氣象局 API 為例，除了須做跨域設定，也須有會員認證的授權碼才能接到資料<br>可參考<a href="https://opendata.cwb.gov.tw/opendatadoc/CWB_Opendata_API_V1.2.pdf" target="_blank" rel="noopener">文件</a>第 7 頁</p>
<p>問題3.CORS是設定在API 的server端？<br>是的，所以說如果server端沒有設定CORS，就無法取得資料</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="測試是否支援CORS的工具"><a href="#測試是否支援CORS的工具" class="headerlink" title="測試是否支援CORS的工具"></a>測試是否支援CORS的工具</h3><p><a href="http://www.test-cors.org/#?client_method=GET&client_credentials=false&server_url=http%3A%2F%2Fopendata2.epa.gov.tw%2FUV%2FUV.json&server_enable=true&server_status=200&server_credentials=false&server_tabs=remote" target="_blank" rel="noopener">test-cors</a></p>
<h3 id="使用-Google-Apps-Script-做中繼點跨網域遠端取得-API-資料"><a href="#使用-Google-Apps-Script-做中繼點跨網域遠端取得-API-資料" class="headerlink" title="使用 Google Apps Script 做中繼點跨網域遠端取得 API 資料"></a>使用 Google Apps Script 做中繼點跨網域遠端取得 API 資料</h3><p>如果是自行練習的網頁可以參考這篇文章進行設定<br><a href="https://medium.com/pvt5r486/javascript-%E5%9C%B0%E4%B8%8B%E5%9F%8E-lv-5-%E5%85%A8%E5%8F%B0%E7%A9%BA%E6%B0%A3%E6%8C%87%E6%A8%99%E5%84%80%E8%A1%A8%E6%9D%BF-b4f163832ff" target="_blank" rel="noopener">JavaScript 地下城 LV 5— 全台空氣指標儀表板</a></p>
<h3 id="未來有空再來細細研究的部分"><a href="#未來有空再來細細研究的部分" class="headerlink" title="未來有空再來細細研究的部分"></a>未來有空再來細細研究的部分</h3><h4 id="JSONP-JSON-with-Padding"><a href="#JSONP-JSON-with-Padding" class="headerlink" title="JSONP (JSON with Padding)"></a>JSONP (JSON with Padding)</h4><p>也是解決跨來源請求的一種方法，但目前應該比較少人使用了。<br>限制：<br>只支援GET請求，要帶的那些參數永遠都只能用附加在網址上的方式（GET）帶過去，沒辦法用 POST。CORS支持所有類型的的HTTP请求</p>
<h4 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h4><p>是比較新的標準，也是用來抓取後端資料用的。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>note</tag>
        <tag>cors</tag>
      </tags>
  </entry>
  <entry>
    <title>設定Hexo的search功能</title>
    <url>/hexo/20191015/3619387531/</url>
    <content><![CDATA[<p>Hexo 架站，預設是沒有站內搜尋的功能。<br>因此，想要站內搜尋需要額外設定。</p><p>Step1.安裝套件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><a id="more"></a>



<p>Step2.在全域的config.yml，加入以下設定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.json</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<p>Step3.修改使用主題的config.yml<br>搜尋<code>local_search</code>，將<code>enable</code>改為true</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

<p>參考資料<br><a href="https://hsiangfeng.github.io/hexo/20190411/932826160/" target="_blank" rel="noopener">架設 Hexo+GitHub</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>vue 插槽 slot</title>
    <url>/vue/20191015/2278892070/</url>
    <content><![CDATA[<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>將每個功能都包成component時，很方便可以直接拿來重複使用。<br>但有時總會有一些想要一些不同，總不能再額外寫一個很像的component，這樣就失去了component的重複使用性了。<br>這時可以透過<code>&lt;slot&gt;</code>標籤，component裡面放一些自定義的文字或內容。<br><code>slot</code>標籤可以想像成是在component裡面挖了一個洞，將你要的內容塞進去。</p><a id="more"></a>
<p>這邊有兩種<del>挖洞的方式</del>，分別是單個插槽（Single Slot）與具名插槽（Named Slots)。</p>
<p>先來看一個沒有使用<code>slot</code>的範例<br>HTML部分：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>沒有插槽可替換的狀態<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">no-slot-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我會被替換掉<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">no-slot-component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-template"</span> <span class="attr">id</span>=<span class="string">"noSlotComponent"</span>&gt;</span></span><br><span class="line"><span class="javascript">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"alert alert-warning"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">h6</span>&gt;</span>我是一個元件<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span><br><span class="line">    這沒有插槽。</span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Javascript部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'no-slot-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'#noSlotComponent'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>結果如圖，只有呈現template裡面原本的內容 “這沒有插槽”。<br>而”替換的內容”卻沒有出現。<br><img src="https://i.imgur.com/zyX4hdp.png" alt></p>
<p>這是為什麼呢？<br>還記得<a href="https://sinyilin.github.io/vue/20190917/3105721319/">生命週期</a>中有個template的橋段<img src="https://i.imgur.com/LyB8o0r.png" alt></p>
<p>如果有template就會執行template 沒有就innerHTML<br>因此，當宣告component時有指定template的話，<br>在使用<component>show me</component>的時候，瀏覽器會去讀取指定template裡的內容，所以說直接寫在component中間的東西是不會被呈現的。<br>但有個例外，那就是使用<code>slot</code> 標籤。</p>
<h2 id="單個插槽（Single-Slot）"><a href="#單個插槽（Single-Slot）" class="headerlink" title="單個插槽（Single Slot）"></a>單個插槽（Single Slot）</h2><p>在template中加入<code>&lt;slot&gt;&lt;/slot&gt;</code>。<br>HTML部分：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Slot 基礎範例<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>以外部資料取代slot<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">single-slot-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>使用這段取代原本的 Slot。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">single-slot-component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-template"</span> <span class="attr">id</span>=<span class="string">"singleSlotComponent"</span>&gt;</span></span><br><span class="line"><span class="javascript">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"alert alert-warning"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">h6</span>&gt;</span>我是一個元件<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span>如果沒有內容，則會顯示此段落。<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Javascript部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'single-slot-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'#singleSlotComponent'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>結果如圖，應該出現”如果沒有內容，則會顯示此段落。”<br>被取代為”使用這段取代原本的 Slot。”<br><img src="https://i.imgur.com/RjaQhH5.png" alt></p>
<p>在上面的範例如果在component裡沒有放其他內容，如下：<br>HTML部分：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>使用compoment slot裡default資料<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">single-slot-component</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">single-slot-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>結果如圖，會直接採用component裡slot的default資料<br><img src="https://i.imgur.com/xUiWnox.png" alt></p>
<h2 id="具名插槽（Named-Slots）"><a href="#具名插槽（Named-Slots）" class="headerlink" title="具名插槽（Named Slots）"></a>具名插槽（Named Slots）</h2><p>這時問題來了，如果想要在一個component裡<del>挖很多洞</del>放很多個<code>slot</code>呢？<br>這時就會需要幫每一個<code>slot</code>命名。<br>HTML部分：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>具名插槽<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">named-slot-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span> <span class="attr">slot</span>=<span class="string">"header"</span>&gt;</span>替換的 Header<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"footer"</span>&gt;</span>替換的 Footer<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"btn"</span>&gt;</span>按鈕內容<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"content"</span>&gt;</span>其餘的內容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">named-slot-component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-template"</span> <span class="attr">id</span>=<span class="string">"namedSlotComponent"</span>&gt;</span></span><br><span class="line"><span class="javascript">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"card my-3"</span>&gt;</span></span><br><span class="line"><span class="javascript">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"card-header"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"header"</span>&gt;</span>這段是預設的文字<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"card-body"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"content"</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">      &lt;h5 <span class="class"><span class="keyword">class</span></span>=<span class="string">"card-title"</span>&gt;Special title treatment&lt;<span class="regexp">/h5&gt;</span></span></span><br><span class="line"><span class="javascript">      &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"card-text"</span>&gt;With supporting text below <span class="keyword">as</span> a natural lead-<span class="keyword">in</span> to additional content.&lt;<span class="regexp">/p&gt;</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">    &lt;a href=<span class="string">"#"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"btn btn-primary"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"btn"</span>&gt;</span>spanGo somewhere<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"card-footer"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"footer"</span>&gt;</span>這是預設的 Footer<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Javascript部分:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'named-slot-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'#namedSlotComponent'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>結果如圖，內容有順利被替換掉。<br><img src="https://i.imgur.com/wR0ATe2.png" alt></p>
<p>不過可以注意到的是，當有name的時候，畫面顯示的順序會依照<br>template內所定義的位置呈現，也就是說在引用component時裡面寫的順序調換不受影響，如下：<br>HTML部分：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>具名插槽<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">named-slot-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"footer"</span>&gt;</span>替換的 Footer<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"btn"</span>&gt;</span>按鈕內容<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"content"</span>&gt;</span>其餘的內容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span> <span class="attr">slot</span>=<span class="string">"header"</span>&gt;</span>替換的 Header<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">named-slot-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上範例的<a href="https://codepen.io/sinyilin/pen/Yzzwabz?editors=1010" target="_blank" rel="noopener">完整程式碼</a></p>
<h2 id="v-slot寫法"><a href="#v-slot寫法" class="headerlink" title="v-slot寫法"></a>v-slot寫法</h2><p>在vue2.6版本時<code>slot</code>出了新的寫法<code>v-slot</code><br>我這邊試寫了一下，範例可以參考<a href="https://codepen.io/sinyilin/pen/LYYNVoQ" target="_blank" rel="noopener">v-slot寫法的程式碼</a></p>
<p>裡面有幾個點需要注意一下</p>
<ul>
<li>v-slot 只能添加到 <code>&lt;template&gt;</code> 或自定義的component上，像是<code>&lt;div&gt;</code>或<code>&lt;p&gt;</code>就會錯誤。舊的寫法就沒有這個限制。</li>
<li>v-slot的缩写是#</li>
<li>但建議若要使用v-slot就從頭到尾都用v-slot，若要用#就從頭到尾都用#</li>
<li>如果要使用<code>v-slot</code>要確認使用的vue的版本是否有支援，版本需2.6以上</li>
</ul>
<h2 id="編譯作用域（Compilation-Scope）"><a href="#編譯作用域（Compilation-Scope）" class="headerlink" title="編譯作用域（Compilation Scope）"></a>編譯作用域（Compilation Scope）</h2><p>編譯作用域是指編譯層級以所在範圍為主，也就是說父層的data由父層的data決定，子層的data由子層的data決定。<br>這邊用來兩個例子來說明</p>
<p>第一個範例：沒有使用<code>slot</code><br><a href="https://codepen.io/sinyilin/pen/QWWNzma" target="_blank" rel="noopener">範例完整程式碼</a></p>
<p>HTML部分</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"child-template"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ok --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Javascript部分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// children component</span></span><br><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  template: <span class="string">'#child-template'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">	  msg: <span class="string">'I\'m child.'</span></span><br><span class="line">	&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// parent component</span></span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">	msg: <span class="string">'I\'m parent.'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>畫面呈現如下：<br><img src="https://i.imgur.com/6Mlluhf.png" alt></p>
<p>會這樣呈現的原因有兩個</p>
<ol>
<li>剛剛提到生命週期的部分，在沒有使用<code>slot</code>的狀況下會直接讀取template裡的內容當模板渲染，因此<code>&lt;child&gt;&lt;/child&gt;</code>會被無視，只呈現<code>&lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</code>的內容</li>
<li>由於編譯作用域的原因，會讀取所在的component的data，所以<code>&lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</code>裡的msg是讀取子component的data</li>
</ol>
<p>第二個範例：有使用<code>slot</code><br><a href="https://codepen.io/sinyilin/pen/xxxVMPO" target="_blank" rel="noopener">範例完整程式碼</a></p>
<p>HTML部分</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>This "msg" is from parent: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"child-template"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span> Default Slot Content <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>畫面呈現如下：<br><img src="https://i.imgur.com/pw52iqi.png" alt></p>
<p>會這樣呈現的原因</p>
<ol>
<li>根據編譯作用域的原因，template中的第一個msg，會讀取子component的data</li>
<li>因為有使用<code>slot</code>，所以<code>&lt;slot&gt;&lt;slot&gt;</code>中會呈現<code>&lt;div&gt;This &quot;msg&quot; is from parent: &lt;/div&gt;</code>，由於<code>&lt;div&gt;This &quot;msg&quot; is from parent: &lt;/div&gt;</code>所在位置為根實體，所以會取得根實體data中的msg呈現</li>
</ol>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li>五倍紅寶石-Vue.js 與 Vuex 前端開發實戰課程</li>
<li>vue出一個電商網站</li>
<li><a href="https://blog.csdn.net/xiaolinlife/article/details/89517928" target="_blank" rel="noopener">vue中的插槽–slot和v-slot</a></li>
<li><a href="https://cythilya.github.io/2017/10/11/vue-component-slot/" target="_blank" rel="noopener">Vue.js: Slot</a></li>
</ul>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue的開發環境建置</title>
    <url>/vue/20191011/1714756113/</url>
    <content><![CDATA[<h2 id="開發環境安裝"><a href="#開發環境安裝" class="headerlink" title="開發環境安裝"></a>開發環境安裝</h2><ul>
<li><p>安裝<a href="https://code.visualstudio.com" target="_blank" rel="noopener">VS code</a></p>
</li>
<li><p>安裝VScode套件 - <a href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer" target="_blank" rel="noopener">Live Server</a> 當簡易伺服器，也有人推薦<a href="https://marketplace.visualstudio.com/items?itemName=yuichinukiyama.vscode-preview-server/" target="_blank" rel="noopener">Preview on Web Server</a>，但我安裝後有錯誤無法排除<br>安裝完後，打開你的專案，點擊右下角的「Go live」，就可以在local端run起你的專案，網站會預設run在<code>http://127.0.0.1:5500/</code>下<br><img src="https://i.imgur.com/TkLdGCs.png" alt></p>
</li>
</ul><a id="more"></a>
<ul>
<li>安裝chrome套件-<a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd" target="_blank" rel="noopener">Vue Devtools</a>觀察資料的變化使用<br>安裝完後，打開chrome只要是透過vue.js開發的網站，都可以使用<br>打開的方式是滑鼠右鍵選檢查，再選擇vue頁籤，即可看到畫面中所使用到的<code>data</code><br><img src="https://i.imgur.com/npmXn7m.png" alt></li>
</ul>
<h2 id="使用vue"><a href="#使用vue" class="headerlink" title="使用vue"></a>使用vue</h2><p>要使用vue有兩種方式</p>
<ul>
<li><p>第一種：使用 CDN 引入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二種：使用vue cli 建置專案<br>透過command line的方式來快速建置專案，CLI v3 之後更提供了圖型化介面來管理</p>
</li>
</ul>
<p>一開始練習可以使用第一種方式進行</p>
<h2 id="vue-版本"><a href="#vue-版本" class="headerlink" title="vue 版本"></a>vue 版本</h2><p>版本分為：</p>
<ul>
<li><p>開發版本<br>支援開發人員工具以及提示報錯等的協助，可以透過F12查看錯誤提示，錯誤訊息也會寫得比較仔細，適合開發時使用。可以透過上面提到的Vue Devtools進行除錯。</p>
</li>
<li><p>正式環境版本：<br>將開發工具都拔除，盡量縮小它的體積，雖然也會有錯誤訊息但不會寫得很仔細，適合在正式環境時使用。<br>被壓縮過，不能使用Vue Devtools來觀看。</p>
</li>
</ul>
<p>另外，好像利用cli build出來都會是生產版本？(有待我之後學到，再回來更新)</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>踏入Vue的世界</title>
    <url>/vue/20191011/1042885337/</url>
    <content><![CDATA[<p>前一陣子開始學vue，會在這邊紀錄學vue的一些學習筆記。<br>學了一段時間後，覺得可以做成筆記，所以筆記的順序可能會有點奇怪。</p><a id="more"></a>
<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><ul>
<li>讀音類似「view」</li>
<li>一套用於建構用戶介面簡單輕量的JS漸進式框架，也能與其他前端框架與函式庫並存共⽤</li>
<li>採用MVVM的概念</li>
<li>版本目前學2.6.10，Vue 3.0 處於RFC階段<ul>
<li>目前是說關於vue3.0 的部分有向下相容，所以只要學新的部分</li>
</ul>
</li>
<li>入門前要會一點HTML、CSS 和 JavaScript</li>
</ul>
<h2 id="何謂漸進式框架"><a href="#何謂漸進式框架" class="headerlink" title="何謂漸進式框架?"></a>何謂漸進式框架?</h2><p>一張圖說明這個概念<br><img src="https://i.imgur.com/yjQtvGa.png" alt><br>Vue.js的核心只關注於view layout的呈現，是提供最小化且必要的功能給予使用者。<br>其餘相關的功能項目都可用其他函式庫或是工具去協助處理。</p>
<p>舉例來說：<br>當你不想透過server-side 進行url的轉換的需求時，可以採用vue-router實現前端路由<br>當有跨component溝通的需求時，可以採用vuex進行狀態管理等等<br>也就是說根據你實際需要去堆疊出各項應用。</p>
<p>也可以參考這篇說明<a href="https://medium.com/@gotraveltoworld/vue-js-%E4%BD%95%E8%AC%82%E6%BC%B8%E9%80%B2%E5%BC%8F%E6%A1%86%E6%9E%B6-7d0281a7efa9" target="_blank" rel="noopener">Vue.js，何謂漸進式框架？</a></p>
<h2 id="MVVM-Model-View-ViewModel-是什麼？"><a href="#MVVM-Model-View-ViewModel-是什麼？" class="headerlink" title="MVVM(Model-View-ViewModel)是什麼？"></a>MVVM(Model-View-ViewModel)是什麼？</h2><p><img src="https://i.imgur.com/B8xMNax.png" alt></p>
<p>M(model):資料的部分<br>V(view):畫面的呈現<br>VM(view-model):雙向數據綁定，會監聽model與view兩邊。</p>
<p>當使用者在操作畫面(View)時，viewModel會監聽狀態，若有改變則會同步修改資料(Model);<br>反之，當資料(Model)有改變時，viewModel會將改變傳回給畫面(View)。因此，不需要手動操作<a href="https://ithelp.ithome.com.tw/articles/10202689" target="_blank" rel="noopener">DOM元素</a>也能更新資料。</p>
<p>相比之下，如果是使用JQuery的話是直接操作DOM元素，vue 是透過資料的狀態(Model)去變動畫面(View)。</p>
<h2 id="從jQuery-到-vue"><a href="#從jQuery-到-vue" class="headerlink" title="從jQuery 到 vue"></a>從jQuery 到 vue</h2><p>講這個之前先來一個小範例，兩個範例都是要取得輸入的值並顯示在網頁上<br><a href="https://codepen.io/sinyilin/pen/KKKdLpO" target="_blank" rel="noopener">使用jQuery的作法</a> vs.<a href="https://codepen.io/sinyilin/pen/MWWadyw" target="_blank" rel="noopener">使用vue的作法</a></p>
<blockquote>
<p>jQuery</p>
</blockquote>
<p>採用指令式渲染，以操作 DOM Node 為基礎的開發模式<br>開發方式直覺，透過 Selector 取得 DOM 就開始操作<br>但程式架構擴⼤複雜後，程式碼混雜不易維護</p>
<blockquote>
<p>Vue</p>
</blockquote>
<p>以操作物件模型為基礎的開發模式。<br>行為關注點放在資料 ( Model ) 與狀態<br>改變的是資料，而不是直接操作 DOM</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>前陣子也去聽了一場演講<a href="https://slides.com/mikecheng1208/deck?fbclid=IwAR3TE9hfZRGAk-vXcK6XsExbWS0C1wqiYK9v2JkNwPHYcWvaUA_nMpveRt0#/0/4" target="_blank" rel="noopener">不vue白不vue ─ 當天就上手的Vue新⼿教學</a>，這邊也提供簡報給大家參考</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p>五倍紅寶石-Vue.js 與 Vuex 前端開發實戰課程</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>為你的Blog做GA流量分析</title>
    <url>/hexo/20190930/1153503290/</url>
    <content><![CDATA[<h2 id="申請Google-Analytics帳號"><a href="#申請Google-Analytics帳號" class="headerlink" title="申請Google Analytics帳號"></a>申請Google Analytics帳號</h2><p>進入<a href="https://analytics.google.com/analytics/web/#/" target="_blank" rel="noopener">Google Analytics</a></p><h4 id="畫面步驟："><a href="#畫面步驟：" class="headerlink" title="畫面步驟："></a>畫面步驟：</h4><p><img src="https://i.imgur.com/y1vPIrC.png" alt></p><h4 id="填寫帳戶名稱"><a href="#填寫帳戶名稱" class="headerlink" title="填寫帳戶名稱"></a>填寫帳戶名稱</h4><p><a href="https://i.imgur.com/1SGX8MV.png" target="_blank" rel="noopener"></a></p><p><img src="https://i.imgur.com/StqGgNv.png" alt></p><h4 id="設定要分析的平台，因為我要追蹤blog，所以選擇web"><a href="#設定要分析的平台，因為我要追蹤blog，所以選擇web" class="headerlink" title="設定要分析的平台，因為我要追蹤blog，所以選擇web"></a>設定要分析的平台，因為我要追蹤blog，所以選擇web</h4><a id="more"></a>



<p><img src="https://i.imgur.com/oJlMxJC.png" alt></p>
<h4 id="設定帳戶資料"><a href="#設定帳戶資料" class="headerlink" title="設定帳戶資料"></a>設定帳戶資料</h4><p><img src="https://i.imgur.com/hQ1Chqe.png" alt></p>
<h4 id="申請完成後就會看到這個畫面"><a href="#申請完成後就會看到這個畫面" class="headerlink" title="申請完成後就會看到這個畫面"></a>申請完成後就會看到這個畫面</h4><p>用法是將這一串code放進網頁中<br>設定路徑在⁨ themes⁩ ▸ ⁨next⁩ ▸ ⁨layout⁩ ▸ ⁨_third-party⁩ ▸ ⁨analytics⁩⁩ ▸ google-analytics.swig<br><img src="https://i.imgur.com/zoEHFPe.png" alt></p>
<h2 id="網頁加入GA"><a href="#網頁加入GA" class="headerlink" title="網頁加入GA"></a>網頁加入GA</h2><h4 id="修改config"><a href="#修改config" class="headerlink" title="修改config"></a>修改config</h4><p>設定next theme下的config.yml<br>搜尋<code>google_analytics</code>後修改<code>tracking_id</code><br>把剛剛畫面中的這串ID貼入<br><img src="https://i.imgur.com/NvfrqKY.png" alt><br>修改結果：<br><img src="https://i.imgur.com/PvgpBAY.png" alt></p>
<p>修改好後重新部署<br>直接試打一下blog網址，可以看到畫面上有資料就代表大功告成了<br><img src="https://i.imgur.com/2sJbbNC.png" alt></p>
<p>不過有個地方我覺得很奇怪，我以為要將全域網站代碼裡的code 貼入header中，但這邊只需要設定config即可。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Google Analytics</tag>
      </tags>
  </entry>
  <entry>
    <title>解決 Hexo code Highlight問題</title>
    <url>/hexo/20190930/1902846998/</url>
    <content><![CDATA[<h2 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h2><p>發了幾篇文章後赫然發現我的程式碼沒有<del>粒粒分明</del>。</p><p>我預期中的code(取自ithome鐵人賽文章)<br><img src="https://i.imgur.com/8rE6dE7.png" alt></p><p>我文章中的code<br><img src="https://i.imgur.com/wbhJ1pH.png" alt></p><a id="more"></a>


<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><p>保留<code>.config.yml</code>中的<code>highlight</code> <code>enable: true</code>設定</p>
<p>在程式碼區塊添加使用的程式語言，如圖<br><img src="https://i.imgur.com/wBST9jR.png" alt></p>
<p>成果：<br><img src="https://i.imgur.com/54Kj1kk.png" alt></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 中 == vs. ===</title>
    <url>/javascript/20190928/3691519072/</url>
    <content><![CDATA[<p>最近看了一些CODE 發現大家在寫js判斷時都會寫===，而不是==，所以查了一下這兩者的差別。</p><h2 id="比較運算式"><a href="#比較運算式" class="headerlink" title="比較運算式"></a>比較運算式</h2><a id="more"></a>
<p>== ：較不嚴謹，只比較「值」。比較時會先進行型別的轉換，再比較裡面的值。<br>===：嚴謹模式，較嚴謹，會比較「型別」與「值」。會先比較型別，如果不相符就會回傳<code>false</code>，不比較值。</p>
<h2 id="一般變數"><a href="#一般變數" class="headerlink" title="一般變數"></a>一般變數</h2><p>以下面這個例子來說，使用==進行比較時會先將<code>num</code>與<code>str</code>轉換成一致的型態。<br>因此，比較時會是一致的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本型別 (ex. int string)</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'3'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num == str); </span><br><span class="line"><span class="comment">//return true</span></span><br><span class="line"><span class="built_in">console</span>.log(num === str);</span><br><span class="line"><span class="comment">//return false</span></span><br></pre></td></tr></table></figure>

<p>不過這時，如果是boolean時，’true’與true 會是不相等的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isOK = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> result = <span class="string">'true'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(isOK == result); </span><br><span class="line"><span class="comment">//return false</span></span><br><span class="line"><span class="built_in">console</span>.log(isOK === result);</span><br><span class="line"><span class="comment">//return false</span></span><br></pre></td></tr></table></figure>

<p><code>true</code> 會自動轉型別為 1<br><code>false</code> 會自動轉型別為 0<br>當使用 === 會發現型別不一致，所以回傳false</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Boolean test2</span></span><br><span class="line"><span class="keyword">var</span> isOK = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> result = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(isOK == result); </span><br><span class="line"><span class="comment">//return true</span></span><br><span class="line"><span class="built_in">console</span>.log(isOK === result);</span><br><span class="line"><span class="comment">//return false</span></span><br></pre></td></tr></table></figure>

<h2 id="Null-amp-undefined-的比較"><a href="#Null-amp-undefined-的比較" class="headerlink" title="Null &amp; undefined 的比較"></a>Null &amp; undefined 的比較</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Null &amp; undefined </span></span><br><span class="line"><span class="keyword">var</span> test;</span><br><span class="line"><span class="keyword">var</span> test2 = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(test == test2);</span><br><span class="line"><span class="comment">//return true</span></span><br><span class="line"><span class="built_in">console</span>.log(test === test2);</span><br><span class="line"><span class="comment">//return false</span></span><br></pre></td></tr></table></figure>

<h2 id="物件"><a href="#物件" class="headerlink" title="物件"></a>物件</h2><p>當比較的型別為「Object」時，是比較是否指向同一個記憶體位置。<br>為什麼是比較記憶體位置呢？<br>這就牽扯到<a href="https://ithelp.ithome.com.tw/articles/10209104" target="_blank" rel="noopener">JS 中Pass by value, or Pass by reference，</a>裡面描述當變數的值是原生型別 (Primitive) 時，行為是 Pass by value，<br>原生型別包含：String、NumberBoolean、Undefined、Null。</p>
<p>當變數的值是物件型別 (Object) 時，行為是 Pass by reference<br>在 JavaScript 中的物件型別常見的例如：Array、Object</p>
<p>當兩個物件指向不同位址時，等式不會成立。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objA = &#123;<span class="string">'name'</span>:<span class="string">'roi'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> objB = &#123;<span class="string">'name'</span>:<span class="string">'roi'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(objA == objB); </span><br><span class="line"><span class="comment">//return false</span></span><br><span class="line"><span class="built_in">console</span>.log(objA === objB);</span><br><span class="line"><span class="comment">//return false</span></span><br><span class="line"><span class="built_in">console</span>.log(objA == &#123;<span class="string">'name'</span>:<span class="string">'roi'</span>&#125;); </span><br><span class="line"><span class="comment">//return false</span></span><br></pre></td></tr></table></figure>

<p>當兩個物件指向同個位址時，等式會成立</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objA = &#123;<span class="string">'name'</span>:<span class="string">'roi'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> objB = objA;</span><br><span class="line"><span class="built_in">console</span>.log(objA == objB); </span><br><span class="line"><span class="comment">//return true</span></span><br><span class="line"><span class="built_in">console</span>.log(objA === objB);</span><br><span class="line"><span class="comment">//return true</span></span><br></pre></td></tr></table></figure>

<p>上面的code，可以改改這邊的<a href="https://codepen.io/sinyilin/pen/jONvBYB" target="_blank" rel="noopener">code</a> 來觀察改變。</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>到底要用== 還是 ===呢？<br>以Null &amp; undefined為例，當你的<code>result</code> 進行了一連串的運算，但中間出了錯誤導致回傳undefined而不是null。但如果你要拿這個判斷來執行後續的行為的話就可能會產生錯誤。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">if</span>(result == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"相符1"</span>); <span class="comment">//會输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(result === <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"相符2"</span>); <span class="comment">//不會输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>為了避免發生類似這樣的錯誤，建議盡量使用嚴謹的===進行比較。</p>
<h2 id="參考資料："><a href="#參考資料：" class="headerlink" title="參考資料："></a>參考資料：</h2><ol>
<li><a href="https://dotblogs.com.tw/alantsai/2013/06/27/106134" target="_blank" rel="noopener">[Javascript] 等於的運用 — ==和 ===的不同之處</a></li>
<li><a href="https://blog.csdn.net/chenchunlin526/article/details/78850171" target="_blank" rel="noopener">JS/JavaScript中两个等号 == 和 三个等号 === 的区别</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10209104" target="_blank" rel="noopener">你不可不知的 JavaScript 二三事#Day26：程式界的哈姆雷特 — — Pass by value, or Pass by reference？</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10103799" target="_blank" rel="noopener">Null &amp; undefined 型態差 </a></li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用GitHub + Hexo 建立個人blogger</title>
    <url>/hexo/20190924/3166793059/</url>
    <content><![CDATA[<h2 id="為什麼選擇利用GitHub-Hexo-作為寫blogger的呢？"><a href="#為什麼選擇利用GitHub-Hexo-作為寫blogger的呢？" class="headerlink" title="為什麼選擇利用GitHub + Hexo 作為寫blogger的呢？"></a>為什麼選擇利用GitHub + Hexo 作為寫blogger的呢？</h2><p>一直以來都在找工具來做技術的筆記，我有用過 Google blogger、Medium、Gitbook、HackMD來寫過。<br>會使用的原因：</p><a id="more"></a>
<ol>
<li>對我來說能讓程式碼跟IDE那樣，<del>粒粒分明</del>是很重要的。<br>我在使用上面那些工具的經驗上是程式碼都沒有Highlight的效果，<del>還是我用得太淺了</del>。<br>Meduim 可以透過額外工具(ex. gist)才能達到Highlight的效果</li>
<li>後期用了Gitbook、HackMD所以比較熟悉markdown的語法</li>
</ol>
<ol start="3">
<li>剛好看到六角學院的影片 <a href="https://www.youtube.com/watch?v=njlABvVRB68" target="_blank" rel="noopener">六角學院 - Github Pages - 免費網頁空間隨你開</a> ，就衝一發了</li>
</ol>
<p>先說自己架站寫技術文章的缺點就是要自己處理SEO問題</p>
<h2 id="起手式-安裝-git-amp-node-js"><a href="#起手式-安裝-git-amp-node-js" class="headerlink" title="起手式     安裝 git &amp; node.js"></a>起手式     安裝 git &amp; node.js</h2><h3 id="安裝git"><a href="#安裝git" class="headerlink" title="安裝git"></a>安裝git</h3><p>因為我使用Mac來開發，所以我是使用之前裝的 Homebrew 軟體來安裝 Git</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安裝 git</span><br><span class="line">$ brew install git</span><br></pre></td></tr></table></figure>

<h3 id="安裝-node-js"><a href="#安裝-node-js" class="headerlink" title="安裝 node.js"></a>安裝 node.js</h3><p><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p>
<h2 id="準備Github與新增Repository"><a href="#準備Github與新增Repository" class="headerlink" title="準備Github與新增Repository"></a>準備Github與新增Repository</h2><p>可以看這個來做 <a href="https://www.youtube.com/watch?v=njlABvVRB68" target="_blank" rel="noopener">六角學院 - Github Pages - 免費網頁空間隨你開</a></p>
<ol>
<li>註冊一個github帳號</li>
<li>建立一個 Repository名稱為 <code>${yourAccount}.github.io</code>，以我的帳號來說就是<code>sinyilin.github.io</code></li>
<li>進入該Repository 設定source 為<code>master branch</code><br><img src="https://i.imgur.com/aVFpJHQ.png" alt></li>
</ol>
<h2 id="各種安裝"><a href="#各種安裝" class="headerlink" title="各種安裝"></a>各種安裝</h2><h3 id="安裝-Hexo"><a href="#安裝-Hexo" class="headerlink" title="安裝 Hexo"></a>安裝 Hexo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安裝</span><br><span class="line">$ npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">#查看安裝版本</span><br><span class="line">$ hexo version</span><br></pre></td></tr></table></figure>

<h3 id="安裝-Hexo-Git"><a href="#安裝-Hexo-Git" class="headerlink" title="安裝 Hexo Git"></a>安裝 Hexo Git</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h3 id="初始化-Hexo"><a href="#初始化-Hexo" class="headerlink" title="初始化 Hexo"></a>初始化 Hexo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init blog  #會建立一個blog資料夾</span><br><span class="line">$ cd blog   #進入該資料夾</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<h2 id="如何與github連接"><a href="#如何與github連接" class="headerlink" title="如何與github連接"></a>如何與github連接</h2><h3 id="設定連結"><a href="#設定連結" class="headerlink" title="設定連結"></a>設定連結</h3><p>進入blog 資料夾，修改blog 資料夾下的_config.yml(全域的config)，如下：</p>
<blockquote>
<p>在全域的config </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: http://github.com/&#123;yourname&#125;/&#123;yourname&#125;.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure>

<p>推上去後可以至 https://{yourname}.github.io/ 查看結果</p>
<h2 id="設定樣式"><a href="#設定樣式" class="headerlink" title="設定樣式"></a>設定樣式</h2><h3 id="選擇主題"><a href="#選擇主題" class="headerlink" title="選擇主題"></a>選擇主題</h3><p>一開始會有一個預設的主題<br>如果看不順眼可以自行選擇主題<br><a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p>
<p>我看蠻多人好像都會使用nexT (在我建置的當下已經到v7.4.0)<br><a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next</a></p>
<p>透過指令將主題載下來</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>我看到另一個感覺也不錯的<a href="https://www.haomwei.com/technology/maupassant-hexo.html" target="_blank" rel="noopener">主題</a></p>
<h3 id="設定blog主題"><a href="#設定blog主題" class="headerlink" title="設定blog主題"></a>設定blog主題</h3><p>在blog資料夾中，有個檔案_config.yml，這個檔案是整個專案的設定檔<br>將裡面的theme 改成next，後重新部署</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#重新部署</span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure>

<p>有時重新部署不會很快更新，這時可以直接在local run做測試</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># local run</span><br><span class="line">$ hexo s --debug</span><br></pre></td></tr></table></figure>

<p>可以透過本機的 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 查看</p>
<h4 id="next又分為四個小主題"><a href="#next又分為四個小主題" class="headerlink" title="next又分為四個小主題"></a>next又分為四個小主題</h4><p>💟 Muse | 🔯 Mist | ♓️ Pisces | ♊️ Gemini<br>可以由next 資料夾中的_config.yml設定<br>直接搜尋Pisces<br>不註解掉的就是要使用的主題</p>
<blockquote>
<p>在next的config </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Scheme Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Schemes</span><br><span class="line">scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>

<h2 id="各種設定"><a href="#各種設定" class="headerlink" title="各種設定"></a>各種設定</h2><p>剛剛有提到有一個是全域的config<br>在主題next內有一個config，這是針對使用該主題的設定</p>
<h3 id="設定整體的blog-基礎資訊"><a href="#設定整體的blog-基礎資訊" class="headerlink" title="設定整體的blog 基礎資訊"></a>設定整體的blog 基礎資訊</h3><blockquote>
<p>在全域的config</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: roi&apos;s blog</span><br><span class="line">subtitle:</span><br><span class="line">description: 在此紀錄我所學到的東西.</span><br><span class="line">keywords:</span><br><span class="line">author: Roi Lin</span><br><span class="line">language: en</span><br><span class="line">timezone:</span><br></pre></td></tr></table></figure>

<h3 id="程式碼呈現方式"><a href="#程式碼呈現方式" class="headerlink" title="程式碼呈現方式"></a>程式碼呈現方式</h3><blockquote>
<p>在next的config</p>
</blockquote>
<p>搜尋 <code>codeblock</code>，<br>總共有這幾種樣式可供選擇 normal | night | night eighties | night blue | night bright<br>我是使用<code>night eighties</code>的</p>
<p>也可選擇要不要開啟複製按鈕</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">highlight_theme: night eighties</span><br><span class="line"># Add copy button on codeblock</span><br><span class="line">copy_button:</span><br><span class="line">  enable: true</span><br><span class="line">  # Show text copy result.</span><br><span class="line">  show_result: true</span><br><span class="line">  # Available values: default | flat | mac</span><br></pre></td></tr></table></figure>

<h3 id="設定menu"><a href="#設定menu" class="headerlink" title="設定menu"></a>設定menu</h3><blockquote>
<p>在next的config</p>
</blockquote>
<p>搜尋 <code>Menu Settings</code>，並修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure>

<h3 id="移除預設”嗯-目前共有-2-篇文章。-繼續努力。”"><a href="#移除預設”嗯-目前共有-2-篇文章。-繼續努力。”" class="headerlink" title="移除預設”嗯..! 目前共有 2 篇文章。 繼續努力。”"></a>移除預設”嗯..! 目前共有 2 篇文章。 繼續努力。”</h3><blockquote>
<p>在next的config</p>
</blockquote>
<p>設定<code>cheers</code> 為<code>false</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Enable &quot;cheers&quot; for archive page.</span><br><span class="line">cheers: false</span><br></pre></td></tr></table></figure>

<h3 id="取消底下的由-Hexo-強力驅動-v3-7-1-主題-—-NexT"><a href="#取消底下的由-Hexo-強力驅動-v3-7-1-主題-—-NexT" class="headerlink" title="取消底下的由 Hexo 強力驅動 v3.7.1 | 主題 — NexT"></a>取消底下的由 Hexo 強力驅動 v3.7.1 | 主題 — NexT</h3><blockquote>
<p>在next的config</p>
</blockquote>
<p>搜尋<code>powered</code> 與<code>theme</code> 改為false</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powered:</span><br><span class="line">  # Hexo link (Powered by Hexo).</span><br><span class="line">  enable: false</span><br><span class="line">  # Version info of Hexo after Hexo link (vX.X.X).</span><br><span class="line">  version: true</span><br><span class="line"></span><br><span class="line">theme:</span><br><span class="line">  # Theme &amp; scheme info link (Theme - NexT.scheme).</span><br><span class="line">  enable: false</span><br><span class="line">  # Version info of NexT after scheme info (vX.X.X).</span><br><span class="line">  version: true</span><br></pre></td></tr></table></figure>

<h3 id="自動新增繼續閱讀"><a href="#自動新增繼續閱讀" class="headerlink" title="自動新增繼續閱讀"></a>自動新增繼續閱讀</h3><p>在首頁的部分會列出所有文章，此時文章都會完全地顯示，很佔版面。<br><img src="https://i.imgur.com/w3dqy01.png" alt><br>解決方法：</p>
<ol>
<li><p>可以在文章中直接添加，顯示閱讀全文按鈕</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一勞永逸作法：</p>
</li>
</ol>
<p>則搜尋 auto_excerpt:，設成true<br>可以在length設定預設斷開的長度</p>
<h3 id="設置樣式總結"><a href="#設置樣式總結" class="headerlink" title="設置樣式總結"></a>設置樣式總結</h3><p>這篇<a href="https://hsiangfeng.github.io/hexo/20190514/1899427194/" target="_blank" rel="noopener">NexT 實用的設定與功能</a>有列出一些blog的設定配置可以參考</p>
<p>另外，這一篇<a href="https://blog.typeart.cc/HEXO%E6%90%AD%E9%85%8D%E4%B8%BB%E9%A1%8Cnext%E5%9F%BA%E7%A4%8E%E9%85%8D%E7%BD%AE%E6%95%99%E5%AD%B8/" target="_blank" rel="noopener">HEXO搭配主題next基礎配置教學</a>也有列出一些設定可以參考<br>這篇文中有提到講到一重點，就是不要太客製化，不然之後升版可能會有問題</p>
<h2 id="新增tags、categories、archives-頁面"><a href="#新增tags、categories、archives-頁面" class="headerlink" title="新增tags、categories、archives 頁面"></a>新增tags、categories、archives 頁面</h2><p>terminal cd至blog根目錄</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br><span class="line">$ hexo new page categories</span><br><span class="line">$ hexo new page about</span><br></pre></td></tr></table></figure>

<p>到source資料夾下新出現的這3個目錄，裡面的index.md各自加上type: “tags”(categories、archives同理)<br>主題會自動渲染成相關頁面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: about</span><br><span class="line">date: 2019-09-15 00:27:20</span><br><span class="line">type: about</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="發表文章"><a href="#發表文章" class="headerlink" title="發表文章"></a>發表文章</h2><h3 id="發新文章"><a href="#發新文章" class="headerlink" title="發新文章"></a>發新文章</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># postName是文章的名稱</span><br><span class="line">$ hexo new &#123;postName&#125;</span><br></pre></td></tr></table></figure>

<p>這時在 source / _post 資料夾中可以看到你剛剛新增的檔案<code>.md</code>檔<br>寫完內容後，重新部署就可以更新blog了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 重新部署</span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure>

<h3 id="設定每篇文章基本資訊-文章分類-categories-與-tags"><a href="#設定每篇文章基本資訊-文章分類-categories-與-tags" class="headerlink" title="設定每篇文章基本資訊 :文章分類 categories 與 tags"></a>設定每篇文章基本資訊 :文章分類 categories 與 tags</h3><p>每一個<code>.md</code>檔 上面都可以設定基礎資訊，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Mac ＆ Win7 port 佔用處理方式</span><br><span class="line">date: 2019-09-14 21:03:58</span><br><span class="line">categories: </span><br><span class="line">- spring boot</span><br><span class="line">tags: </span><br><span class="line">- port</span><br><span class="line">- command line</span><br><span class="line">- spring boot</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="編輯已發表的文章"><a href="#編輯已發表的文章" class="headerlink" title="編輯已發表的文章"></a>編輯已發表的文章</h3><p>直接編輯<code>.md</code>檔案<br>再重新部署</p>
<h3 id="刪除文章"><a href="#刪除文章" class="headerlink" title="刪除文章"></a>刪除文章</h3><p>直接刪除目錄中的<code>.md</code> 然後下指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean    # 清除快取檔案和已產生的靜態檔案。</span><br><span class="line">$ hexo d -g     # d = deploy, g = generate</span><br></pre></td></tr></table></figure>

<h2 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h2><p>我目前都是在HackMD 上面寫完草稿，完成後就直接發，所以比較少用到這個功能<br>可以參考這篇 <a href="https://novnan.github.io/Hexo/hexo-draft/" target="_blank" rel="noopener">Hexo 文章保存为草稿</a></p>
<h2 id="安裝第三方套件"><a href="#安裝第三方套件" class="headerlink" title="安裝第三方套件"></a>安裝第三方套件</h2><h3 id="設定每篇文章閱讀量"><a href="#設定每篇文章閱讀量" class="headerlink" title="設定每篇文章閱讀量"></a>設定每篇文章閱讀量</h3><p>如果想要觀察自己的blogger有多少人看的話可以設定<br>設定又分成兩種<br>一種是全站的 <a href="http://theme-next.iissnan.com/third-party-services.html#analytics-busuanzi" target="_blank" rel="noopener">不蒜子统计</a><br>一種是文章單獨分開計算的 <a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a></p>
<h4 id="配置LeanCloud"><a href="#配置LeanCloud" class="headerlink" title="配置LeanCloud"></a>配置LeanCloud</h4><p>可參考這兩篇<br><a href="https://qinzhaokun.github.io/2017/06/10/%E4%BD%BF%E7%94%A8leancloud%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E9%98%85%E8%AF%BB%E6%AC%A1%E6%95%B0/" target="_blank" rel="noopener">使用leancloud给博客添加阅读次数</a></p>
<p><a href="https://vonsdite.cn/posts/74d5335f.html" target="_blank" rel="noopener">Hexo Next leancloud文章阅读次数配置以及插件无效问题解决</a></p>
<p>不過因為leanCloud 現在創建應用需要實名認證，實名認證需要掃支付寶，因此我放棄使用</p>
<h2 id="留言板-Disqus"><a href="#留言板-Disqus" class="headerlink" title="留言板 Disqus"></a>留言板 Disqus</h2><p>可以參考此篇 <a href="https://ithelp.ithome.com.tw/articles/10208619" target="_blank" rel="noopener">部落格第三方服務介紹</a>進行Disqus的申請</p>
<p>在設定的部分，打開Disqus</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Disqus</span><br><span class="line">disqus:</span><br><span class="line">  enable: true</span><br><span class="line">  shortname: roi-blog</span><br><span class="line">  count: false</span><br><span class="line">  lazyload: false</span><br><span class="line">  #post_meta_order: 0</span><br></pre></td></tr></table></figure>

<p>設定完後你可能會發現，部分頁面不想給別人下評論ex. tag 跟category頁面<br>可以透過設定<code>.md</code>檔的基礎資訊來排除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Categories</span><br><span class="line">date: 2019-09-15 00:22:40</span><br><span class="line">type: categories</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="讓大家找得到你的blog-SEO"><a href="#讓大家找得到你的blog-SEO" class="headerlink" title="讓大家找得到你的blog SEO"></a>讓大家找得到你的blog SEO</h2><h3 id="對google-search的設定"><a href="#對google-search的設定" class="headerlink" title="對google search的設定"></a>對google search的設定</h3><p>我先依照這篇來做 <a href="https://hoxis.github.io/Hexo+Next%20SEO%E4%BC%98%E5%8C%96.html" target="_blank" rel="noopener">Hexo博客的优化方法，以Google搜索为例</a></p>
<h3 id="網站整體的調整"><a href="#網站整體的調整" class="headerlink" title="網站整體的調整"></a>網站整體的調整</h3><p>這兩篇也有提到一些注意事項</p>
<ol>
<li><p><a href="https://hjptriplebee.github.io/hexo%E7%9A%84SEO%E6%96%B9%E6%B3%95.html/" target="_blank" rel="noopener">hexo的SEO方法</a></p>
</li>
<li><p><a href="http://blog.mobing.net/content/hexo/hexo-next-seo.html" target="_blank" rel="noopener">基于Hexo中Next主题的SEO优化指南</a></p>
</li>
</ol>
<h3 id="當文章越來越多時-該怎麼管理"><a href="#當文章越來越多時-該怎麼管理" class="headerlink" title="當文章越來越多時 該怎麼管理"></a>當文章越來越多時 該怎麼管理</h3><p>本站還沒開始做，但未來可能會參考這篇來做<br><a href="https://usedfire.net/Notes/Hexo/make-hexo-post-category-by-folder/" target="_blank" rel="noopener">Hexo - 使文章依文章分類為資料夾名稱置放</a></p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.youtube.com/watch?v=njlABvVRB68" target="_blank" rel="noopener">六角學院 - Github Pages - 免費網頁空間隨你開</a></p>
<p><a href="https://yaoandy107.github.io/hexo-tutorial/" target="_blank" rel="noopener">Hexo+GitHub，新手也可以快速建立部落格</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 生命週期 (Lifecycle)</title>
    <url>/vue/20190917/3105721319/</url>
    <content><![CDATA[<p>最近開始接觸Vue，趁著記憶還很新的時候記錄一下我所記得的內容。<br>Vue的生命週期就是Vue的實體(Instance)到從建立-&gt;更新-&gt;摧毀的這段過程。<br>官方在這段過程中提供一些方法(Hook function)給開發者進行使用，如下圖中的紅色方框。</p><a id="more"></a>
<p><img src="https://i.imgur.com/NGrlgPg.png" alt></p>
<p>當我們生命週期到某一個點的時候就會觸發這個Hook function，因此可以在特定的時間點對Vue實體進行操作。</p>
<p>以下是我對Vue生命週期的解釋:</p>
<h2 id="Vue-生命週期"><a href="#Vue-生命週期" class="headerlink" title="Vue 生命週期"></a>Vue 生命週期</h2><p>以下我利用紅色將 Highlight Hook function 標示出來: </p>
<h3 id="1-new-Vue"><a href="#1-new-Vue" class="headerlink" title="1.new Vue() :"></a>1.new Vue() :</h3><p>建立Vue的實體</p>
<h3 id="2-beforeCreate"><a href="#2-beforeCreate" class="headerlink" title="2.beforeCreate :"></a><font style="color:red">2.beforeCreate :</font></h3><p>尚未初始化前，無法取得vue 實體裡的 <code>vm.$data</code>，也不會生成DOM元素。</p>
<h3 id="3-Observe-Data-amp-Init-Events："><a href="#3-Observe-Data-amp-Init-Events：" class="headerlink" title="3.Observe Data &amp; Init Events："></a>3.Observe Data &amp; Init Events：</h3><p>開始初始化。</p>
<h3 id="4-Created："><a href="#4-Created：" class="headerlink" title=" 4.Created："></a><font style="color:red"> 4.Created：</font></h3><p>實體已經建立，屬性已綁定，因此在此才能拿到 vue 實體裡的<code>vm.$ data</code>，不過DOM元素還沒有生成。</p>
<h3 id="5-判斷實體裡面的-el是否有被掛載"><a href="#5-判斷實體裡面的-el是否有被掛載" class="headerlink" title="5.判斷實體裡面的$.el是否有被掛載"></a>5.判斷實體裡面的<code>$.el</code>是否有被掛載</h3><p>如果沒有的話後續就都不會執行直到vm.$mount()被呼叫；有的話會繼續往下執行。</p>
<h3 id="6-判斷實體內是否有template-屬性"><a href="#6-判斷實體內是否有template-屬性" class="headerlink" title="6.判斷實體內是否有template 屬性"></a>6.判斷實體內是否有template 屬性</h3><p>有的話就使用template 的內容當作樣板之後用來render 畫面；沒有的話就使用綁定el的html當作樣板之後用來render 畫面。</p>
<h3 id="7-beforeMount："><a href="#7-beforeMount：" class="headerlink" title=" 7.beforeMount："></a><font style="color:red"> 7.beforeMount：</font></h3><p>DOM元素渲染到畫面上以前調用。<br>模板 (template) 編譯並掛載至 HTML 之前，此時template中被綁定的元素還尚未轉換為要輸出的HTML，例如還是。</p>
<h3 id="8-模板-template-編譯與掛載"><a href="#8-模板-template-編譯與掛載" class="headerlink" title="8.模板(template)編譯與掛載"></a>8.模板(template)編譯與掛載</h3><h3 id="9-mounted："><a href="#9-mounted：" class="headerlink" title="  9.mounted："></a><font style="color:red">  9.mounted：</font></h3><p>DOM元素渲染到畫面上後後調用。<br>模板 (template) 編譯並掛載至 HTML 之後，此時template中被綁定的元素已轉換為要輸出的HTML，例如0。此時就好像JQuery中的ready()。</p>
<h3 id="10-beforeUpdate："><a href="#10-beforeUpdate：" class="headerlink" title="10.beforeUpdate："></a><font style="color:red">10.beforeUpdate：</font></h3><p>更新前，在這邊可以取得更新前與後的資料。</p>
<h3 id="11-Create-el-…-and-replace-el-："><a href="#11-Create-el-…-and-replace-el-：" class="headerlink" title="11.Create $.el ….and replace el ："></a>11.Create $.el ….and replace el ：</h3><p>render 畫面</p>
<h3 id="12-updated："><a href="#12-updated：" class="headerlink" title=" 12.updated："></a><font style="color:red"> 12.updated：</font></h3><p>更新後。</p>
<h3 id="13-activated："><a href="#13-activated：" class="headerlink" title="13. activated："></a><font style="color:red">13. activated：</font></h3><p>有使用<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>才會用到。</p>
<h3 id="14-deactivated："><a href="#14-deactivated：" class="headerlink" title="14.deactivated："></a><font style="color:red">14.deactivated：</font></h3><p>有使用<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>才會用到。</p>
<h3 id="15-beforeDestroy："><a href="#15-beforeDestroy：" class="headerlink" title="15. beforeDestroy："></a><font style="color:red">15. beforeDestroy：</font></h3><p>實體被摧毀前。</p>
<h3 id="16-destroyed："><a href="#16-destroyed：" class="headerlink" title="16.destroyed："></a><font style="color:red">16.destroyed：</font></h3><p>實體摧毀，監聽事件、子實體會被銷毀。</p>
<h2 id="範例程式"><a href="#範例程式" class="headerlink" title="範例程式"></a>範例程式</h2><p>這邊有一段 沒有使用<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>的 <a href="https://codepen.io/sinyilin/pen/xxKqYGO" target="_blank" rel="noopener">code</a> 可以幫助理解，可以透過console來觀看生命週期。<br>一開始console如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;beforeCreate - this.count: &quot; undefined</span><br><span class="line">&quot;beforeCreate - this.$el: &quot; undefined</span><br><span class="line">&quot;created - this.count: &quot; 0</span><br><span class="line">&quot;created - this.$el: &quot; undefined</span><br><span class="line">&quot;beforeMount - this.$el: &quot; &quot;&lt;div id=&apos;app&apos;&gt;</span><br><span class="line">&lt;h1&gt; &#123;&#123; count &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;button class=&apos;btn btn-primary&apos; @click=&apos;add&apos;&gt;Count&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;&quot;</span><br><span class="line">&quot;mounted - this.$el: &quot; &quot;&lt;div id=&apos;app&apos;&gt;&lt;h1&gt; 0&lt;/h1&gt; &lt;button class=&apos;btn btn-primary&apos;&gt;Count&lt;/button&gt;&lt;/div&gt;&quot;</span><br></pre></td></tr></table></figure>

<ol>
<li>可以看到<code>beforeCreate</code>階段時，因為還沒init，所以data 跟 el 都取不到。</li>
<li><code>created</code>時 可以取到data 但還沒確認el。</li>
<li><code>beforeMount</code>時可以取得模板。</li>
<li><code>mounted</code>時取得模板並綁定屬性。</li>
</ol>
<h3 id="更新時的console"><a href="#更新時的console" class="headerlink" title="更新時的console:"></a>更新時的console:</h3><p>第一個數字為畫面上的html取得的，第二個數字為this.count</p>
<p>這時你可能會有一個疑惑為什麼在beforeUpdate時的this.count 不是0，而是1。</p>
<p>因為這邊的this.count已經是觸發更新後的數字，只是尚未呈現在畫面上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;beforeUpdate: &quot; &quot;0&quot; 1</span><br><span class="line">&quot;updated: &quot; &quot;1&quot; 1</span><br></pre></td></tr></table></figure>

<h3 id="此範例中注意事項"><a href="#此範例中注意事項" class="headerlink" title="此範例中注意事項"></a>此範例中注意事項</h3><p>在練習這個範例時除了遇到<code>beforeUpdate</code>時的疑問外，還有幾個需要注意的點：</p>
<ol>
<li>如果vue 實體中沒有綁定<code>el</code> 的話，<code>beforeMount</code>以後的hook function都不能使用。</li>
<li>destroyed是銷毀監聽方法、子元素、data，但html要自己手動清除。</li>
<li>destroyed要記得寫在el綁定的元素外面，不然摧毀事件會被刪除。</li>
</ol>
<h3 id="lt-keep-alive-gt-lt-keep-alive-gt"><a href="#lt-keep-alive-gt-lt-keep-alive-gt" class="headerlink" title="&lt;keep-alive&gt; &lt;/keep-alive&gt;"></a><code>&lt;keep-alive&gt; &lt;/keep-alive&gt;</code></h3><p>用途：舉個例子做頁籤時或填寫表單時還是希望保留狀態，保留資料狀態不將實體<code>destroyed</code>。<br>使用該標籤時不會進入<code>beforeDestroy</code>與<code>destroyed</code>，而是變成<code>activated</code>與<code>deactivated</code>。</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>了解Vue實體的生命週期可以讓你在對的階段做對的事。</p>
<p>舉個例子，像是透過ajax取得資料時應該要寫實體建立階段的<code>created</code>之後， 也就是<code>created</code>、<code>beforeMount</code> 與 <code>mounted</code>。<br><img src="https://i.imgur.com/9p9T8DL.png" alt></p>
<p>有人是建議放<code>created</code>，不建議在<code>mounted</code> 因為網頁畫面可能會有一段空白，但可以用loading 圖蓋過。</p>
<p>也有人建議放<code>mounted</code>，理由是所有DOM都準備好才塞資料</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li>五倍紅寶石-Vue.js 與 Vuex 前端開發實戰課程</li>
<li><a href="https://cn.vuejs.org/v2" target="_blank" rel="noopener">https://cn.vuejs.org/v2</a></li>
</ul>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac ＆ Win7 port 佔用處理方式 (kill Process)</title>
    <url>/spring-boot/20190914/3254661455/</url>
    <content><![CDATA[<p>Spring boot 運作時會佔用掉一個port ，若無良好關閉，會導致程式無法在該port執行。<br>因為我太容易忘記了，所以在這邊做一點紀錄。<br>這邊分為 Mac 跟  Win7來講：</p><a id="more"></a>
<h2 id="Mac-OX"><a href="#Mac-OX" class="headerlink" title="[Mac OX]"></a>[Mac OX]</h2><p>會因為osx版本不一樣會有不同做法，我目前電腦的版本是10.13<br>1.列出佔用該port的process</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 範本lsof -i tcp:&#123;port num&#125;</span><br><span class="line">$ lsof -i tcp:7006</span><br></pre></td></tr></table></figure>

<p>2.取得PID，刪除該process</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 範本 kill -9 &#123;pId&#125;</span><br><span class="line">$ kill -9 12334</span><br></pre></td></tr></table></figure>

<h2 id="Windows7"><a href="#Windows7" class="headerlink" title="[Windows7]"></a>[Windows7]</h2><p>列出佔用該port的process，LISTENING後的的數字為PID。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 範本 netstat -nao |find &quot;0.0.0.0:&#123;port num&#125;&quot;</span><br><span class="line">$ netstat -nao |find &quot;0.0.0.0:7006&quot;</span><br></pre></td></tr></table></figure>

<p>2.找出該process是什麼，也可忽略這個步驟，因為上面已經取的PID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 範本 tasklist /fi &quot;pid eq 4116&quot;</span><br><span class="line">$ tasklist /fi &quot;pid eq 4116&quot;</span><br></pre></td></tr></table></figure>

<p>3.刪除佔用該port的process</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 範本 taskkill /pid &#123;pid num&#125; /F</span><br><span class="line">$ taskkill /pid 4116 /F</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>port</tag>
        <tag>command line</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
</search>
